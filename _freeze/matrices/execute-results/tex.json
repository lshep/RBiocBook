{
  "hash": "c1bd70c8ca20598f927250b0102dd0ae",
  "result": {
    "engine": "knitr",
    "markdown": "# Matrices\n\nA _matrix_ is a rectangular collection of the same data type (see @fig-datastructures_schematic). It can be viewed\nas a collection of column vectors all of the same length and the same type\n(i.e. numeric, character or logical) OR a collection of row vectors, again all\nof the same type and length. A _data.frame_ is *also* a rectangular array. All\nof the columns must be the same length, but they **may be** of *different* types.\nThe rows and columns of a matrix or data frame can be given names. However\nthese are implemented differently in R; many operations will work for one but\nnot both, often a source of confusion.\n\n![A matrix is a collection of column vectors.](images/datastructures_schematic.png){#fig-datastructures_schematic}\n\n\n## Creating a matrix\n\nThere are many ways to create a matrix in R. One of the simplest is to use the\n`matrix()` function. In the code below, we'll create a matrix from a vector\nfrom 1:16.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n```\n\n\n:::\n:::\n\n\nThe same is possible, but specifying that the matrix be \"filled\" by row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4,byrow = TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n```\n\n\n:::\n:::\n\n\nNotice the subtle difference in the order that the numbers go into the matrix.\n\n\nWe can also build a matrix from parts by \"binding\" vectors together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10 \ny <- rnorm(10)\n```\n:::\n\n\nEach of the vectors above is of length 10 and both are \"numeric\", so we can make\nthem into a matrix. Using `rbind` binds rows (**r**) into a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- rbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1]     [,2]     [,3]      [,4]      [,5]      [,6]      [,7]      [,8]\nx  1.000000 2.000000 3.000000  4.000000 5.0000000 6.0000000 7.0000000 8.0000000\ny -1.383674 1.022323 1.188663 -1.068186 0.4360454 0.9917045 0.5836144 0.5213843\n        [,9]     [,10]\nx  9.0000000 10.000000\ny -0.4447755  0.781375\n```\n\n\n:::\n:::\n\n\nThe alternative to `rbind` is `cbind` that binds columns (**c**) together. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- cbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x          y\n [1,]  1 -1.3836742\n [2,]  2  1.0223233\n [3,]  3  1.1886630\n [4,]  4 -1.0681859\n [5,]  5  0.4360454\n [6,]  6  0.9917045\n [7,]  7  0.5836144\n [8,]  8  0.5213843\n [9,]  9 -0.4447755\n[10,] 10  0.7813750\n```\n\n\n:::\n:::\n\n\nInspecting the names associated with rows and columns is often useful,\nparticularly if the names have human meaning. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\nWe can also change the names of the matrix by assigning _valid_ names to the \ncolumns or rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mat) = c('apples','oranges')\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apples\"  \"oranges\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      apples    oranges\n [1,]      1 -1.3836742\n [2,]      2  1.0223233\n [3,]      3  1.1886630\n [4,]      4 -1.0681859\n [5,]      5  0.4360454\n [6,]      6  0.9917045\n [7,]      7  0.5836144\n [8,]      8  0.5213843\n [9,]      9 -0.4447755\n[10,]     10  0.7813750\n```\n\n\n:::\n:::\n\n\n\n\nMatrices have dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  2\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n## Accessing elements of a matrix\n\nIndexing for matrices works as for vectors except that we now need to\ninclude both the row and column (in that order). We can access elements \nof a matrix using the square bracket [ indexing method. Elements can be \naccessed as `var[r, c]`. Here, `r` and `c` are vectors describing the elements\nof the matrix to select.\n\n::: {.callout-important}\nThe indices in R start with one, meaning that the first element of a vector or the first row/column of a matrix is indexed as one.\n\nThis is different from some other programming languages, such as Python, which use zero-based indexing, meaning that the first element of a vector or the first row/column of a matrix is indexed as zero.\n\nIt is important to be aware of this difference when working with data in R, especially if you are coming from a programming background that uses zero-based indexing. Using the wrong index can lead to unexpected results or errors in your code.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The 2nd element of the 1st row of mat\nmat[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  oranges \n-1.383674 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first ROW of mat\nmat[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   apples   oranges \n 1.000000 -1.383674 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first COLUMN of mat\nmat[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# and all elements of mat that are > 4; note no comma\nmat[mat>4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n## [1]  5  6  7  8  9 10\n```\n:::\n\n\n::: {.callout-caution}\nNote that in the last case, there is no \",\", so R treats the matrix as a long \nvector (length=20). This is convenient, sometimes, but it can also be a source \nof error, as some code may \"work\" but be doing something unexpected.\n\n:::\n\n\n\nWe can also use indexing to exclude a row or column by prefixing the selection\nwith a `-` sign.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[,-1]       # remove first column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -1.3836742  1.0223233  1.1886630 -1.0681859  0.4360454  0.9917045\n [7]  0.5836144  0.5213843 -0.4447755  0.7813750\n```\n\n\n:::\n\n```{.r .cell-code}\nmat[-c(1:5),]  # remove first five rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     apples    oranges\n[1,]      6  0.9917045\n[2,]      7  0.5836144\n[3,]      8  0.5213843\n[4,]      9 -0.4447755\n[5,]     10  0.7813750\n```\n\n\n:::\n:::\n\n\n## Changing values in a matrix\n\nWe can create a matrix filled with random values drawn from a normal\ndistribution for our work below. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = matrix(rnorm(20),nrow=10)\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                 V2         \n Min.   :-1.54340   Min.   :-1.4190  \n 1st Qu.:-0.67168   1st Qu.:-0.9032  \n Median : 0.06123   Median :-0.1002  \n Mean   :-0.02654   Mean   :-0.2634  \n 3rd Qu.: 0.55115   3rd Qu.: 0.1103  \n Max.   : 1.25409   Max.   : 0.9455  \n```\n\n\n:::\n:::\n\n\nMultiplication and division works similarly to vectors. When multiplying by a \nvector, for example, the values of the vector are reused. In the simplest case, \nlet's multiply the matrix by a constant (vector of length 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# multiply all values in the matrix by 20\nm2 = m*20\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                 V2         \n Min.   :-30.8681   Min.   :-28.379  \n 1st Qu.:-13.4336   1st Qu.:-18.064  \n Median :  1.2246   Median : -2.005  \n Mean   : -0.5307   Mean   : -5.267  \n 3rd Qu.: 11.0230   3rd Qu.:  2.206  \n Max.   : 25.0819   Max.   : 18.910  \n```\n\n\n:::\n:::\n\n\nBy combining subsetting with assignment, we can make changes to just part of a \nmatrix. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# and add 100 to the first column of m\nm2[,1] = m2[,1] + 100\n# summarize m\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1               V2         \n Min.   : 69.13   Min.   :-28.379  \n 1st Qu.: 86.57   1st Qu.:-18.064  \n Median :101.22   Median : -2.005  \n Mean   : 99.47   Mean   : -5.267  \n 3rd Qu.:111.02   3rd Qu.:  2.206  \n Max.   :125.08   Max.   : 18.910  \n```\n\n\n:::\n:::\n\n\nA somewhat common transformation for a matrix is to transpose which changes\nrows to columns. One might need to do this if an assay output from a lab \nmachine puts samples in rows and genes in columns, for example, while in \nBioconductor/R, we often want the samples in columns and the genes in rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]      [,3]       [,4]       [,5]      [,6]      [,7]\n[1,] 124.333765 125.081871  97.70854 101.300544 101.148731 106.68670 73.979815\n[2,]  -2.214361  -1.795608 -22.58731  -1.454317  -4.492802  10.77263  3.425541\n          [,8]     [,9]     [,10]\n[1,] 112.46845 69.13193  82.85241\n[2,] -24.85817 18.90987 -28.37912\n```\n\n\n:::\n:::\n\n\n## Calculations on matrix rows and columns\n\nAgain, we just need a matrix to play with. We'll use `rnorm` again, but with a\nslight twist. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3 = matrix(rnorm(100,5,2),ncol=10) # what does the 5 mean here? And the 2?\n```\n:::\n\n\nSince these data are from a normal distribution, we can look at a row (or column)\nto see what the mean and standard deviation are.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.585108\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7807432\n```\n\n\n:::\n\n```{.r .cell-code}\n# or a row\nmean(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.367885\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.459511\n```\n\n\n:::\n:::\n\n\nThere are some useful convenience functions for computing means and sums \nof data in **all** of the columns and rows of matrices. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 5.585108 5.616137 4.437312 6.001155 5.826136 6.218967 5.763700 5.683374\n [9] 5.058097 4.419581\n```\n\n\n:::\n\n```{.r .cell-code}\nrowMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6.367885 5.364585 5.475563 4.690024 4.948899 6.060900 6.223290 5.552056\n [9] 5.290125 4.636241\n```\n\n\n:::\n\n```{.r .cell-code}\nrowSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 63.67885 53.64585 54.75563 46.90024 49.48899 60.60900 62.23290 55.52056\n [9] 52.90125 46.36241\n```\n\n\n:::\n\n```{.r .cell-code}\ncolSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 55.85108 56.16137 44.37312 60.01155 58.26136 62.18967 57.63700 56.83374\n [9] 50.58097 44.19581\n```\n\n\n:::\n:::\n\n\nWe can look at the distribution of column means:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save as a variable\ncmeans = colMeans(m3)\nsummary(cmeans)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.420   5.190   5.650   5.461   5.811   6.219 \n```\n\n\n:::\n:::\n\nNote that this is centered pretty closely around the selected mean of `5` above.\n\nHow about the standard deviation? There is not a `colSd` function, but it turns\nout that we can easily apply functions that take vectors as input, like `sd` and\n\"apply\" them across either the rows (the first dimension) or columns (the second)\ndimension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsds = apply(m3, 2, sd)\nsummary(csds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7807  1.6781  1.9775  1.9495  2.2203  3.0281 \n```\n\n\n:::\n:::\n\n\nAgain, take a look at the distribution which is centered quite close to the \nselected standard deviation when we created our matrix.\n\n\n## Exercises\n\n\n\n\n### Data preparation\n\nFor this set of exercises, we are going to rely on a dataset that comes with R.\nIt gives the number of sunspots per month from 1749-1983. The dataset comes as \na `ts` or time series data type which I convert to a matrix using the following\ncode. \n\nJust run the code as is and focus on the rest of the exercises. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(sunspots)\nsunspot_mat <- matrix(as.vector(sunspots),ncol=12,byrow = TRUE)\ncolnames(sunspot_mat) <- as.character(1:12)\nrownames(sunspot_mat) <- as.character(1749:1983)\n```\n:::\n\n\n### Questions\n\n-   After the conversion above, what does `sunspot_mat` look like? Use functions\nto find the number of rows, the number of columns, the class, and some basic\nsummary statistics.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ncol(sunspot_mat)\n    nrow(sunspot_mat)\n    dim(sunspot_mat)\n    summary(sunspot_mat)\n    head(sunspot_mat)\n    tail(sunspot_mat)\n    ```\n    :::\n\n\n\n-   Practice subsetting the matrix a bit by selecting:\n    - The first 10 years (rows)\n    - The month of July (7th column)\n    - The value for July, 1979 using the rowname to do the selection.\n  \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    sunspot_mat[1:10,]\n    sunspot_mat[,7]\n    sunspot_mat['1979',7]\n    ```\n    :::\n\n\n\n1.  These next few exercises take advantage of the fact that calling a univariate\nstatistical function (one that expects a vector) works for matrices by just making\na vector of all the values in the matrix. \nWhat is the highest (max) number of sunspots recorded in these data?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    max(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the minimum?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    min(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the overall mean and median?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    mean(sunspot_mat)\n    median(sunspot_mat)\n    ```\n    :::\n\n\n1.  Use the `hist()` function to look at the distribution of all the monthly \nsunspot data. \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat)\n    ```\n    :::\n\n1.  Read about the `breaks` argument to `hist()` to try to increase the number of\nbreaks in the histogram to increase the resolution slightly. Adjust your `hist()`\nand breaks to your liking.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat, breaks=40)\n    ```\n    :::\n\n\n\n1.  Now, let's move on to summarizing the data a bit to learn about the pattern of \nsunspots varies by month or by year. Examine the dataset again. What do the\ncolumns represent? And the rows?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # just a quick glimpse of the data will give us a sense\n    head(sunspot_mat)\n    ```\n    :::\n\n\n1.  We'd like to look at the distribution of sunspots by month. How can we do that?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # the mean of the columns is the mean number of sunspots per month.\n    colMeans(sunspot_mat)\n    \n    # Another way to write the same thing:\n    apply(sunspot_mat, 2, mean)\n    ```\n    :::\n\n1.  Assign the month summary above to a variable and summarize it to get a sense\nof the spread over months.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    monthmeans = colMeans(sunspot_mat)\n    summary(monthmeans)\n    ```\n    :::\n\n\n1.  Play the same game for years to get the per-year mean?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ymeans = rowMeans(sunspot_mat)\n    summary(ymeans)\n    ```\n    :::\n\n\n1.  Make a plot of the yearly means. Do you see a pattern?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    plot(ymeans)\n    # or make it clearer\n    plot(ymeans, type='l')\n    ```\n    :::\n\n\n\n\n\n\n\n",
    "supporting": [
      "matrices_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}