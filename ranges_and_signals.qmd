---
title: "Genomic ranges and features"
output: 
  html_document
---

```{r init, include=FALSE}
library(knitr)
opts_chunk$set(message=FALSE)
Biocpkg <- function(pkg) paste0("[`", pkg, "`](http://bioconductor.org/packages/", pkg, ".html)")
```

## Introduction

Genomic ranges are essential components in the field of genomics, representing intervals on the genome that specify the start and end positions of DNA segments. These ranges can denote various genomic features, such as genes, exons, regulatory elements, and regions identified in genomic studies like ChIP-seq peaks. They play a pivotal role in the annotation, comparison, and interpretation of genomic features and experimental data, making them indispensable in biological data analysis.

Understanding genomic ranges begins with the concept of coordinate systems. Different databases and tools adopt different conventions for indexing genomic coordinates. For instance, the UCSC Genome Browser uses a 0-based coordinate system, while Ensembl employs a 1-based system. Moreover, genomic ranges often include strand information, indicating whether the feature is on the positive or negative DNA strand, which is crucial for correctly interpreting gene expression and other genomic functions.

Genomic ranges come in various forms, from single ranges defined by a simple start and end position (such as a single exon) to complex multi-range sets encompassing collections of ranges like all exons of a gene. Manipulating these ranges involves several fundamental operations. Intersection allows researchers to find overlapping regions between two sets of ranges, such as identifying ChIP-seq peaks that overlap with promoter regions. Union operations combine multiple ranges into a single contiguous range, while set difference identifies regions in one set that do not overlap with another set.

Several tools and libraries have been developed to facilitate the manipulation of genomic ranges. In the R programming environment, the Bioconductor project provides the GenomicRanges package, which is specifically designed for representing and manipulating genomic ranges. This package offers a variety of functions for range arithmetic and efficient overlap queries. Another useful R package is rtracklayer, which enables the import and export of genomic data in various formats, including BED and GFF files.

For those who prefer a command-line interface, BEDTools offers a suite of utilities for performing a wide range of operations on genomic intervals. This toolset is highly versatile, supporting tasks like intersecting, merging, and complementing genomic intervals. In the Python ecosystem, PyRanges provides a fast and flexible library for manipulating genomic intervals, offering similar functionality to Bioconductor’s GenomicRanges.

The applications of genomic ranges are diverse and far-reaching. In gene annotation, for instance, RNA-seq reads are mapped to known gene models to quantify gene expression levels. Variant annotation involves mapping variants identified from sequencing data to their genomic context, predicting functional consequences based on their location within genes or intergenic regions. Comparative genomics leverages genomic ranges to compare intervals between species, identifying conserved regions that might indicate essential functional elements. Epigenomic studies utilize genomic ranges to intersect DNA methylation data or histone modification peaks with genomic features, providing insights into regulatory mechanisms.

Despite their utility, working with genomic ranges presents several challenges. Converting coordinates between different reference genomes or different versions of the same genome can be complex and prone to errors. Integrating diverse types of genomic data, such as DNA sequences, epigenetic marks, and RNA-seq data, requires meticulous handling of genomic coordinates and ranges to ensure accurate analyses. Moreover, the sheer scale of genomic data necessitates optimized algorithms and data structures to handle large datasets efficiently.

Interpreting genomic ranges within their biological context is crucial for drawing meaningful conclusions. For instance, a range within a gene’s promoter region might indicate potential regulatory activity. Understanding the functional implications of genomic ranges often involves overlapping these ranges with known functional elements, such as enhancers or silencers, to infer gene regulation mechanisms and their phenotypic consequences. Tools like the UCSC Genome Browser and the Integrative Genomics Viewer (IGV) are invaluable for visualizing genomic ranges alongside other genomic annotations, aiding in the interpretation and exploration of genomic data.

## Bioconductor and GenomicRanges

```{r loadlib}
library(GenomicRanges)
```
The Bioconductor `r Biocpkg("GenomicRanges")` package is a comprehensive toolkit designed to handle and manipulate genomic intervals and variables systematized on these intervals [@lawrence_software_2013]. Developed by Bioconductor, this package simplifies the complexity of managing genomic data, facilitating the efficient exploration, manipulation, and visualization of such data. GenomicRanges aids in dealing with the challenges of genomic data, including its massive size, intricate relationships, and high dimensionality.

The GenomicRanges package in Bioconductor covers a wide range of use cases related to the management and analysis of genomic data. Here are some key examples:

* Genomic Feature Manipulation
  : The GenomicRanges and GRanges classes can be used to represent and manipulate various genomic features such as genes, transcripts, exons, or single-nucleotide polymorphisms (SNPs). Users can query, subset, resize, shift, or sort these features based on their genomic coordinates.
* Genomic Interval Operations
  : The GenomicRanges package provides functions for performing operations on genomic intervals, such as finding overlaps, nearest neighbors, or disjoint intervals. These operations are fundamental to many types of genomic data analyses, such as identifying genes that overlap with ChIP-seq peaks, or finding variants that are in close proximity to each other.
* Alignments and Coverage
  : The GAlignments and GAlignmentPairs classes can be used to represent alignments of sequencing reads to a reference genome, such as those produced by a read aligner. Users can then compute coverage of these alignments over genomic ranges of interest, which is a common task in RNA-seq or ChIP-seq analysis.
* Annotation and Metadata Handling
  : The metadata column of a GRanges object can be used to store various types of annotation data associated with genomic ranges, such as gene names, gene biotypes, or experimental scores. This makes it easy to perform analyses that integrate genomic coordinates with other types of biological information.
* Genome Arithmetic
  : The GenomicRanges package supports a version of "genome arithmetic", which includes set operations (union, intersection, set difference) as well as other operations (like coverage, complement, or reduction) that are adapted to the specificities of genomic data.
* Efficient Data Handling
  : The CompressedGRangesList class provides a space-efficient way to represent a large list of GRanges objects, which is particularly useful when working with large genomic datasets, such as whole-genome sequencing data.

The GenomicRanges package in Bioconductor uses the S4 class system (see @tbl-genomic-ranges-classes), which is a part of the methods package in R. The S4 system is a more rigorous and formal approach to object-oriented programming in R, providing enhanced capabilities for object design and function dispatch.

|Class Name           |Description                                                                     |Potential Use |
|---------------------|--------------------------------------------------------------------------------|------|
|GRanges              |Represents a collection of genomic ranges and associated variables.             |ChipSeq peaks, CpG islands, etc. |
|GRangesList          |Represents a list of GenomicRanges objects.                                     |transcript models (exons, introns) |
|RangesList           |Represents a list of Ranges objects.                                            |  |
|IRanges              |Represents a collection of integer ranges.                                      |used mainly to *build* GRanges, etc. |
|GPos                 |Represents genomic positions.                                                   |SNPs or other single nicleotide locations |
|GAlignments          |Represents alignments against a reference genome.                               |Sequence read locations from a BAM file |
|GAlignmentPairs      |Represents pairs of alignments, typically representing a single fragment of DNA.|Paired-end sequence alignments |

: Classes within the GenomicRanges package. Each class has a slightly different use case.  {#tbl-genomic-ranges-classes}{tbl-colwidths="[20,40,40]"}

In the context of the GenomicRanges package, the S4 class system allows for the creation of complex, structured data objects that can effectively encapsulate genomic intervals and associated data. This system enables the package to handle the complexity and intricacy of genomic data.

For example, the GenomicRanges class in the package is an S4 class that combines several basic data types into a composite object. It includes slots for sequence names (seqnames), ranges (start and end positions), strand information, and metadata. Each slot in the S4 class corresponds to a specific component of the genomic data, and methods (see @tbl-single-granges-methods and @tbl-multiple-granges-methods) can be defined to interact with these slots in a structured and predictable way.

| **Method**            | **Description**                                                                         |
|-----------------------|-----------------------------------------------------------------------------------------|
| **length**            | Returns the number of ranges in the GRanges object.                                     |
| **seqnames**          | Retrieves the sequence names of the ranges.                                             |
| **ranges**            | Retrieves the start and end positions of the ranges.                                    |
| **strand**            | Retrieves the strand information of the ranges.                                         |
| **elementMetadata**   | Retrieves the metadata associated with the ranges.                                      |
| **seqlevels**         | Returns the levels of the factor that the seqnames slot is derived from.                |
| **seqinfo**           | Retrieves the Seqinfo (sequence information) object associated with the GRanges object. |
| **start, end, width** | Retrieve or set the start or end positions, or the width of the ranges.                 |
| **resize**            | Resizes the ranges.                                                                     |
| **subset, [, [[, $**  | Subset or extract elements from the GRanges object.                                     |
| **sort**              | Sorts the GRanges object.                                                               |
| **shift**             | Shifts the ranges by a certain number of base pairs.                                    |

: Methods for accessing, manipulating single objects {#tbl-single-granges-methods}

The S4 class system also supports inheritance, which allows for the creation of specialized subclasses that share certain characteristics with a parent class but have additional features or behaviors.

The S4 system's formalism and rigor make it well-suited to the complexities of bioinformatics and genomic data analysis. It allows for the creation of robust, reliable code that can handle complex data structures and operations, making it a key part of the GenomicRanges package and other Bioconductor packages.



| **Method**            | **Description**                                                                         |
|-----------------------|-----------------------------------------------------------------------------------------|
| **findOverlaps**      | Finds overlaps between different sets of ranges.                                        |
| **countOverlaps**     | Counts overlaps between different sets of ranges.                                       |
| **subsetByOverlaps**  | Subsets the ranges based on overlaps.                                                   |
| **distanceToNearest** | Computes the distance to the nearest range in another set of ranges.                    |

: Methods for comparing and combining multiple GenomicRanges-class objects {#tbl-multiple-granges-methods}











## The GRanges class---
title: "ATAC-Seq with Bioconductor"
author:
- name: Sean Davis
  affiliation: National Cancer Institute
  email: seandavi@gmail.com
package: AtacSeqWorkshop
output:
  - BiocStyle::html_document
  - BiocStyle::pdf_document
abstract: |
  This workshop employs Bioconductor GenomicRanges and GenomicFeatures infrastructure to perform basic import of aligned reads followed by quality control of an ATAC-Seq dataset. It will also examine how to use fragment length (insert size) to isolate chromatin compartments of interest such as putative nucleosome-free regions. Moving on to a multi-sample analysis, peak regions (called separately) will inform similarities between samples. Statistical identification of differential accessibility will provide a second measure of sample differences and serve as potential regions of interest for enrichment analysis and biological hypothesis generation. Data visualization throughout using the Integrated Genome Viewer (IGV) can make findings more intuitive, so students are encouraged to export datasets from R in formats compatible with IGV.
bibliography: atac.bib
link-citations: true
vignette: |
  %\VignetteIndexEntry{ATAC-Seq with Bioconductor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include=FALSE}
library(knitr)
library(BiocStyle)
opts_chunk$set(cache=TRUE, message=FALSE, warning=FALSE)
```

# Overview {.unnumbered}


## Pre-requisites {.unnumbered}

This workshop assumes:

* A working and up-to-date version of R
* Basic knowledge of R syntax
* Familiarity with the `r Biocpkg('GenomicRanges')` package and range manipulations
* Familiarity with BAM files and their contents

## Participation {.unnumbered}

After a very brief review of ATAC-Seq and chromatin accessibility, students will work 
independently to follow this workflow. Additional materials are provided as links at
the end of the workshop for those wanting deeper exposure. Additional materials
include alignment from FASTQ files and peak calling.

## _R_ / _Bioconductor_ packages used {.unnumbered}

- `r Biocpkg('Rsamtools')`  
- `r Biocpkg('GenomicRanges')`  
- `r Biocpkg('GenomicFeatures')`  
- `r Biocpkg('GenomicAlignments')` 
- `r Biocpkg('rtracklayer')` 
- `r Biocpkg('heatmaps')`

## Time outline {.unnumbered}

An example for a 45-minute workshop:

| Activity                     | Time |
|------------------------------|------|
| Introduction                 | 15m  |
| Independent work             | 2-3hr  |
| Additional exercises (optional, external) | up to 12 hours   |


## Learning goals {.unnumbered}

* Describe how to import sequence alignments in BAM format into R
* Relate fragment size to genomic characteristics such as nucleosome occupancy and open chromatin.
* Perform basic alignment manipulations in R to enrich ATAC-seq data for chromatin characteristics.
* Gain familiarity with the IGV genome browser and examining data in genomic context.
* Visualize summaries of genomic signal using profile plots and heatmaps.

## Learning objectives {.unnumbered}

* Load and save genomic data in BAM and BigWig formats [GenomicAlignments and rtracklayer].
* Perform basic QC plots from ATAC-Seq data.
* Isolate nucleosome-free and mononucleosome regions from ATAC-seq data.
* Install and use IGV to visualize data in genomic context.
* Create profile plots using the heatmaps package.

# Background

Chromatin accessibility assays measure the extent to which DNA is open and accessible.
Such assays now use high throughput sequencing as a quantitative readout. DNAse assays, first using microarrays[@Crawford2006-nt] and then DNAse-Seq [@Crawford2006-bk], requires a larger amount of DNA and is labor-indensive and has been largely supplanted by ATAC-Seq [@Buenrostro2013-dz]. 

The Assay for Transposase Accessible Chromatin with high-throughput sequencing (ATAC-seq) method maps chromatin accessibility genome-wide. This method quantifies DNA accessibility with a hyperactive Tn5 transposase that cuts and inserts sequencing adapters into regions of chromatin that are accessible. High throughput sequencing of fragments produced by the process map to regions of increased accessibility, transcription factor binding sites, and nucleosome positioning. The method is both fast and sensitive and can be used as a replacement for DNAse _and_ MNase.

An early review of chromatin accessibility assays [@Tsompana2014-yh] compares the use cases, pros and cons, and expected signals from each of the most common approaches (Figure \@ref(fig:chromatinAssays)).

```{r chromatinAssays, echo=FALSE, fig.cap="Chromatin accessibility methods, compared. Representative DNA fragments generated by each assay are shown, with end locations within chromatin defined by colored arrows. Bar diagrams represent data signal obtained from each assay across the entire region. The footprint created by a transcription factor (TF) is shown for ATAC-seq and DNase-seq experiments."}
knitr::include_graphics('images/chromatin_accessibility_buck.png')
```

The first manuscript describing ATAC-Seq protocol and findings outlined how ATAC-Seq data "line up" with other datatypes such as ChIP-seq and DNAse-seq (Figure \@ref(fig:greenleaf)). They also highlight how fragment length correlates with specific genomic regions and characteristics [@Buenrostro2013-dz, Figure 3].

```{r greenleaf, echo=FALSE, fig.cap='Multimodal chromatin comparisons. From [@Buenrostro2013-dz], Figure 4. (a) CTCF footprints observed in ATAC-seq and DNase-seq data, at a specific locus on chr1. (b) Aggregate ATAC-seq footprint for CTCF (motif shown) generated over binding sites within the genome (c) CTCF predicted binding probability inferred from ATAC-seq data, position weight matrix (PWM) scores for the CTCF motif, and evolutionary conservation (PhyloP). Right-most column is the CTCF ChIP-seq data (ENCODE) for this GM12878 cell line, demonstrating high concordance with predicted binding probability.'}
knitr::include_graphics("images/greenleaf_chip_dnase_atac.png")
```

Buenrostro et al. provide a detailed protocol for performing ATAC-Seq and quality control of results [@Buenrostro2015-dz]. Updated and modified protocols that improve on signal-to-noise and reduce input DNA requirements have been described.

## Informatics overview

ATAC-Seq protocols typically utilize paired-end sequencing protocols. The reads are aligned to the respective _genome_ using `bowtie2`, `BWA`, or other short-read aligner. The result, after appropriate manipulation, often using `samtools`, results in a BAM file. Among other details, the BAM format includes columns for:

```{r bamshot, fig.cap="A BAM file in text form. The output of `samtools view` is the text format of the BAM file (called SAM format). Bioconductor and many other tools use BAM files for input. Note that BAM files also often include an index `.bai` file that enables random access into the file; one can read just a genomic region without having to read the entire file."}
knitr::include_graphics('images/bam_shot.png')
```

- sequence name (`chr1`)
- start position (integer)
- a _CIGAR_ string that describes the alignment in a compact form
- the sequence to which the pair aligns
- the position to which the pair aligns
- a bit flag field that describes multiple characteristics of the alignment
- the sequence and quality string of the read
- additional tags that tend to be aligner-specific


Duplicate fragments (those with the *same* start and end position of other reads) are marked and likely discarded. Reads that fail to align "properly" are also often excluded from analysis. It is worth noting that most software packages allow simple "marking" of such reads and that there is usually no need to create a special BAM file before proceeding with downstream work. 

After alignment and BAM processing, the workflow can switch to _Bioconductor_. 

## Working with sequencing data in Bioconductor

The _Bioconductor_ project includes several infrastructure packages for dealing with ranges (sequence name, start, end, +/- strand) on sequences [@Lawrence2013-he] as well as capabilities with working with Fastq files directly [@morgan2016rsamtools].

| Package  | Use cases |
|---|---|
| `r Biocpkg('Rsamtools')`  | low level access to FASTQ, VCF, SAM, BAM, BCF formats   |
| `r Biocpkg('GenomicRanges')`  | Container and methods for handling genomic reagions   |
| `r Biocpkg('GenomicFeatures')`  | Work with transcript databases, gff, gtf and BED formats  |
| `r Biocpkg('GenomicAlignments')` | Reader for BAM format |
| `r Biocpkg('rtracklayer')` | import and export multiple UCSC file formats including BigWig and Bed |

Table: Commonly used Bioconductor and their high-level use cases.

As noted in the previous section, the output of an ATAC-Seq experiment is a BAM file. 
As paired-end sequencing is a commonly-applied approach for ATAC-Seq, the `readGAlignmentPairs` function
is the appropriate method to use. 

# Data import and quality control



```{r message=FALSE}
library(GenomicAlignments)
```

Reading a paired-end BAM file looks a bit complicated, but the following code will:

1. Read the included BAM file.
2. Include read pairs only (`isPaired = TRUE`)
3. Include properly paired reads (`isProperPair = TRUE`)
4. Include reads with mapping quality >= 1
5. Add a couple of additional fields, `mapq` (mapping quality) and `isize` (insert size) to the default fields. 


```{r readGreenleaf}
greenleaf = readGAlignmentPairs(
  system.file(package='AtacSeqWorkshop',
              'extdata/Sorted_ATAC_21_22.bam'),
  param = ScanBamParam(
    mapqFilter = 1, 
    flag = scanBamFlag(
      isPaired = TRUE, 
      isProperPair = TRUE), 
    what = c("mapq", "isize")))
```

*Exercise*: What is the class of `greenleaf`?
*Exercise*: Use the `GenomicAlignments::first()` accessor to get the first read of the pair as a `GAlignments` object. Save the result as a variable called `gl_first_read`. Use the `mcols` accessor to find the "metadata columns" of `gl_first_read`.
*Exercise*: How many read pairs map to each chromosome? 


We can make plot of the number of reads mapping to each chromosome. 

```{r}
library(ggplot2)
library(dplyr)
chromCounts = table(seqnames(greenleaf)) %>% 
  data.frame() %>%
  dplyr::rename(chromosome=Var1, count = Freq)
```

To keep things small, the example BAM file includes only chromosomes 21 and 22. 

```{r plotChromCounts, fig.cap="Reads per chromosome. In our example data, we are using only chromosomes 21 and 22."}
ggplot(chromCounts, aes(x=chromosome, y=count)) + 
  geom_bar(stat='identity') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Normalizing by the chromosome length can yield the reads per megabase which should crudely be similar across all chromosomes.

```{r chromReadProps}
chromCounts = chromCounts %>%
  dplyr::mutate(readsPerMb = (count/(seqlengths(greenleaf)/1e6)))
```


And show a plot. For two chromosomes, this is a little underwhelming. 

```{r plotReadProps, fig.cap = "Read counts normalized by chromosome length. This is not a particularly important plot, but it can be useful to see the relative contribution of each chromosome given its length."}
ggplot(chromCounts, aes(x=chromosome, y=readsPerMb)) + 
  geom_bar(stat='identity') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  theme_bw()
```

## Coverage

The `coverage` method for genomic ranges calculates, for each base, the number of overlapping features. In the case of a BAM file from ATAC-Seq converted to a GAlignmentPairs object, the coverage gives us an idea of the extent to which reads pile up to form peaks. 



```{r}
cvg = coverage(greenleaf)
class(cvg)
```

The coverage is returned as a `SimpleRleList` object. Using `names` can get us the names of the elements of the list.

```{r}
names(cvg)
```

There is a name for each chromosome. Looking at the `chr21` entry:

```{r}
cvg$chr21
```

we see that each chromosome is represented as an `Rle`, short for run-length-encoding. Simply put, since along the chromosome there are many repeated values, we can recode the long vector as a set of (length: value) pairs. For example, if the first 9,410,000 base pairs have `0` coverage, we encode that as (9,410,000: 0). Doing that across the chromosome can very significantly reduce the memory use for genomic coverage. 

The following little function, `plotCvgHistByChrom` can plot a histogram of the coverage for a chromosome. 


```{r}
plotCvgHistByChrom = function(cvg, chromosome) {
  library(ggplot2)
  cvgcounts = as.data.frame(table(cvg[[chromosome]]))
  cvgcounts[,1] = as.numeric(as.character(cvgcounts[,1]))
  colnames(cvgcounts) = c('Coverage', 'Count')
  ggplot(cvgcounts, aes(x=Coverage, y=Count)) + 
    ggtitle(paste("Chromosome",chromosome)) + 
    geom_point(alpha=0.5) + 
    geom_smooth(span=0.2) + 
    scale_y_log10() +
    theme_bw() 
}
for(i in c('chr21', 'chr22')) {
  print(plotCvgHistByChrom(cvg, i))
}
```

## Fragment Lengths

The first ATAC-Seq manuscript [@Buenrostro2013-dz] highlighted the relationship between fragment length and nucleosomes (see Figure \@ref{fig:flgreenleaf}).

```{r flgreenleaf, fig.cap="Relationship between fragment length and nucleosome number."}
knitr::include_graphics('https://cdn.ncbi.nlm.nih.gov/pmc/blobs/0ad9/3959825/fde39a9fb288/nihms554473f2.jpg')
```

Remember that we loaded the example BAM file with insert sizes (`isize`). We can use that "column" to examine the fragment lengths (another name for insert size). Also, note that the insert size for the `first` read and the `second` are the same (absolute value). Here, we will use `first`.

```{r results='hide'}
GenomicAlignments::first(greenleaf)
mcols(GenomicAlignments::first(greenleaf))
class(mcols(GenomicAlignments::first(greenleaf)))
head(mcols(GenomicAlignments::first(greenleaf))$isize)
fraglengths = abs(mcols(GenomicAlignments::first(greenleaf))$isize)
```

We can plot the fragment length density (histogram) using the `density` function.

```{r fraglength, fig.cap="Fragment length histogram. "}
plot(density(fraglengths, bw=0.05), xlim=c(0,1000))
```

*Exercise*: Adjust the `xlim`, `bw`, and try `log="y"` in the plot to highlight features present in figure \ref{fig:flgreenleaf}.

And for fun, the ggplot2 version:

```{r}
library(dplyr)
library(ggplot2)
fragLenPlot <- table(fraglengths) %>% data.frame %>% rename(InsertSize = fraglengths, 
    Count = Freq) %>% mutate(InsertSize = as.numeric(as.vector(InsertSize)), 
    Count = as.numeric(as.vector(Count))) %>% ggplot(aes(x = InsertSize, y = Count)) + 
    geom_line()
print(fragLenPlot + theme_bw() + lims(x=c(-1,250)))
```

Knowing that the nucleosome-free regions will have insert sizes shorter than one nucleosome, we can isolate the read pairs that have that characteristic.

```{r}
gl_nf = greenleaf[mcols(GenomicAlignments::first(greenleaf))$isize<100]
```

And the mononucleosome reads will be between 187 and 250 base pairs for insert size/fragment length.

```{r}
gl_mn = greenleaf[mcols(GenomicAlignments::first(greenleaf))$isize>187 & 
                  mcols(GenomicAlignments::first(greenleaf))$isize<250  ]
```

Finally, we expect nucleosome-free reads to be enriched near the TSS while mononucleosome reads should not be. We will use the `r Biocpkg('heatmaps')` package to take a look at these two sets of reads with respect to the tss of the human genome.

```{r}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
proms = promoters(TxDb.Hsapiens.UCSC.hg19.knownGene, 250, 250)
seqs = c('chr21','chr22')
seqlevels(proms, pruning.mode='coarse') = seqs # only chromosome 21 and 22
```

Take a look at the `r Biocpkg('heatmaps')` package vignette to learn more about the heatmaps package capabilities.

```{r fig.cap = "Enrichment of nucleosome free reads just upstream of the TSS."}
library(heatmaps)
gl_nf_hm = CoverageHeatmap(proms,coverage(gl_nf),coords=c(-250,250))
label(gl_nf_hm) = "NucFree"
scale(gl_nf_hm)=c(0,10)
plotHeatmapMeta(gl_nf_hm)
```

```{r fig.cap = "Depletion of nucleosome free reads just upstream of the TSS."}
gl_mn_hm = CoverageHeatmap(proms,coverage(gl_mn),coords=c(-250,250))
label(gl_mn_hm) = "MonoNuc"
scale(gl_mn_hm)=c(0,10)
plotHeatmapMeta(gl_mn_hm)
```

```{r fig.cap = "Comparison of signals at TSS. Mononucleosome data on the left, nucleosome-free on the right."}
plotHeatmapList(list(gl_mn_hm, gl_nf_hm))
```


# Viewing data in IGV

Install IGV from [here](https://software.broadinstitute.org/software/igv/download).

We export the greenleaf data as a BigWig file.

```{r exportBW}
library(rtracklayer)
export.bw(coverage(greenleaf),'greenleaf.bw')
```

*Exercise*: In IGV, choose `hg19`. Then, load the `greenleaf.bw` file and explore chromosomes 21 and 22. 
*Exercise*: Export the nucleosome-free portion of the data as a BigWig file and examine that in IGV. Where do you expect to see the strongest signals? 

# Additional work

For those working extensively on ATAC-Seq, there is a great workflow/tutorial available from Thomas Carrol:

https://rockefelleruniversity.github.io/RU_ATAC_Workshop.html

Feel free to work through it. In addition to the work above, there is also the `r Biocpkg('ATACseqQC')` package vignette that offers more than just QC. At least a couple more packages are available in _Bioconductor_.


# Appendix {.unnumbered}

## Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

## MACS2 {.unnumbered}

The MACS2 package is a commonly-used package for calling peaks. Installation
and other details are available[^macs].

[^macs]: https://github.com/taoliu/MACS

```
pip install macs2
```

# References


To get going, we can construct a `GRanges` object by hand as an example.

The `GRanges` class represents a collection of genomic ranges that each have a single start
and end location on the genome. It can be used to store the location of genomic features
such as contiguous binding sites, transcripts, and exons. These objects can be created by
using the GRanges constructor function. The following code just creates a `GRanges` object 
from scratch.

```{r mkexample}
gr <- GRanges(
    seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)),
    ranges = IRanges(101:110, end = 111:120, names = head(letters, 10)),
    strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)),
    score = 1:10,
    GC = seq(1, 0, length=10))
gr
```

This creates a `GRanges` object with 10 genomic ranges. The output of the `GRanges` `show()` method
separates the information into a left and right hand region that are separated by `|` symbols (see @fig-granges-structure).
The genomic coordinates (seqnames, ranges, and strand) are located on the left-hand side
and the metadata columns are located on the right. For this example, the
metadata is comprised of score and GC information, but almost anything can be stored in
the metadata portion of a GRanges object.

![The structure of a `GRanges` object, which behaves a bit like a vector of ranges, although the analogy is not perfect. A `GRanges` object is composed of the "Ranges" part the lefthand box, the "metadata" columns (the righthand box), and a "seqinfo" part that describes the names and lengths of associated sequences. Only the "Ranges" part is required. The figure also shows a few of the "accessors" and approaches to subsetting a `GRanges` object.](images/granges_structure.png){#fig-granges-structure}


The components of the genomic coordinates within a GRanges object can be extracted using
the seqnames, ranges, and strand accessor functions.

```{r GRanges-location-accessors}
seqnames(gr)
ranges(gr)
strand(gr)
```

Note that the `GRanges` object has information to the "left" side of the `|` that has special 
accessors. The information to the right side of the `|`, when it is present, is the metadata
and is accessed using `mcols()`, for "metadata columns".

```{r mcols-example}
class(mcols(gr))
mcols(gr)
```

Since the `class` of `mcols(gr)` is `r class(mcols(gr))`, we can use our `DataFrame` approaches to 
work with the data.

```{r mcols-df-methods}
mcols(gr)$score
```

We can even assign a new column.

```{r new-mcols-column}
mcols(gr)$AT = 1-mcols(gr)$GC
gr
```


Another common way to create a `GRanges` object is to start with a `data.frame`, perhaps created
by hand like below or read in using `read.csv` or `read.table`. We can convert from a 
`data.frame`, when columns are named appropriately, to a `GRanges` object. 

```{r granges-from-data.frame}
df_regions = data.frame(chromosome = rep("chr1",10),
                        start=seq(1000,10000,1000),
                        end=seq(1100, 10100, 1000))
as(df_regions,'GRanges') # note that names have to match with GRanges slots
## fix column name
colnames(df_regions)[1] = 'seqnames'
gr2 = as(df_regions,'GRanges')
gr2
```

`GRanges` have one-dimensional-like behavior. For instance, we can check the `length` and 
even give `GRanges` names.

```{r names-and-length}
names(gr)
length(gr)
```

### Subsetting GRanges objects

While `GRanges` objects look a bit like a `data.frame`, they can be thought of
as vectors with associated ranges. Subsetting, then, works very similarly to
vectors. To subset a `GRanges` object to include only second and third regions:

```{r subsetgr1}
gr[2:3]
```

That said, if the `GRanges` object has metadata columns, we can also treat
it like a two-dimensional object kind of like a data.frame. Note that
the information to the left of the `|` is not like a `data.frame`, so
we *cannot* do something like `gr$seqnames`. Here is an example of subsetting
with the subset of one metadata column.

```{r subsetgr2}
gr[2:3, "GC"]
```

The usual `head()` and `tail()` also work just fine.

```{r othergrstuff}
head(gr,n=2)
tail(gr,n=2)
```

### Interval operations on one GRanges object

#### Intra-range methods

The methods described in this section work *one-region-at-a-time* and are, therefore, called
"intra-region" methods. Methods that work across all regions are described below 
in the [Inter-range methods] section.

The `GRanges` class has accessors for the "ranges" part of the data. For example:

```{r basicgrfuncs}
## Make a smaller GRanges subset
g <- gr[1:3]
start(g) # to get start locations
end(g)   # to get end locations
width(g) # to get the "widths" of each range
range(g) # to get the "range" for each sequence (min(start) through max(end))
```

The GRanges class also has many methods for manipulating the ranges. The methods can
be classified as intra-range methods, inter-range methods, and between-range methods.
Intra-range methods operate on each element of a GRanges object independent of the other
ranges in the object. For example, the flank method can be used to recover regions flanking
the set of ranges represented by the GRanges object. So to get a GRanges object containing
the ranges that include the 10 bases *upstream* of the ranges:

```{r grflank}
flank(g, 10)
```

Note how `flank` pays attention to "strand". 
To get the flanking regions *downstream* of the ranges, we can do:

```{r grflank2}
flank(g, 10, start=FALSE)
```

Other examples of intra-range methods include `resize` and `shift`. The shift method will
move the ranges by a specific number of base pairs, and the resize method will extend the
ranges by a specified width.

```{r shiftandresize}
shift(g, 5)
resize(g, 30)
```

The `r Biocpkg("GenomicRanges")` help page `?"intra-range-methods"` summarizes these methods.

#### Inter-range methods

Inter-range methods involve comparisons between ranges in a single GRanges object. For
instance, the reduce method will align the ranges and merge overlapping ranges to produce
a simplified set.

```{r grreduce}
reduce(g)
```

The reduce method could, for example, be used to collapse individual overlapping coding
exons into a single set of coding regions.

Sometimes one is interested in the gaps or the qualities of the gaps between the ranges
represented by your GRanges object. The gaps method provides this information:

```{r}
gaps(g)
```

In this case, we have not specified the lengths of the chromosomes, so Bioconductor is 
making the assumption (incorrectly) that the chromosomes end at the largest location
on each chromosome. We can correct this by setting the `seqlengths` correctly, but
we can ignore that detail for now.

The disjoin method represents a GRanges object as a collection of non-overlapping ranges:

```{r disjoin}
disjoin(g)
```


The `coverage` method quantifies the degree of overlap for all the ranges in a GRanges object.

```{r coveragegr1}
coverage(g)
```

The coverage is summarized as a `list` of coverages, one for each chromosome. 
The `Rle` class is used to store the values. Sometimes, one must convert these 
values to `numeric` using `as.numeric`. In many cases, this will happen automatically,
though. 

```{r coveragegr2}
covg = coverage(g)
covg_chr2 = covg[['chr2']]
plot(covg_chr2, type='l')
```

See the `r Biocpkg("GenomicRanges")` help page `?"intra-range-methods"` for more details.

### Set operations for GRanges objects

Between-range methods calculate relationships between different GRanges objects. Of central
importance are findOverlaps and related operations; these are discussed below. Additional
operations treat GRanges as mathematical sets of coordinates; union(g, g2) is the union of
the coordinates in g and g2. Here are examples for calculating the union, the intersect and
the asymmetric difference (using setdiff).




```{r intervalsgr1}
g2 <- head(gr, n=2)
union(g, g2)
intersect(g, g2)
setdiff(g, g2)
```

There is extensive additional help available or by looking at the vignettes
in at the `r Biocpkg("GenomicRanges")` pages.

```{r helppagesgr,eval=FALSE}
?GRanges
```

There are also many possible `methods` that work with `GRanges` objects. To
see a complete list (long), try:

```{r granges-methods-help, eval=FALSE}
methods(class="GRanges")
```


## GRangesList

Some important genomic features, such as spliced transcripts that are are comprised of exons,
are inherently compound structures. Such a feature makes much more sense when expressed
as a compound object such as a GRangesList. If we thing of each transcript as a set of exons,
each transcript would be summarized as a `GRanges` object. However, if we have multiple transcripts,
we want to somehow keep them separate, with each transcript having its own exons. The `GRangesList`
is then a list of `GRanges` objects that. Continuing with the transcripts thought, a `GRangesList`
can contain all the transcripts and their exons; each transcript is an element in the list. 

![The structure of a GRangesList, which is a `list` of GRanges objects. While the analogy is not perfect, a `GRangesList` behaves a bit like a list. Each element in the `GRangesList` *is* a `Granges` object. A common use case for a `GRangesList` is to store a list of transcripts, each of which have exons as the regions in the `GRanges`. ](images/granges_list_structure.png){#fig-granges-list-structure}


Whenever genomic features consist of multiple
ranges that are grouped by a parent feature, they can be represented as a GRangesList
object. Consider the simple example of the two transcript GRangesList below created using
the GRangesList constructor.


```{r example-granges-list-1}
gr1 <- GRanges(
    seqnames = "chr1", 
    ranges = IRanges(103, 106),
    strand = "+", 
    score = 5L, GC = 0.45)
gr2 <- GRanges(
    seqnames = c("chr1", "chr1"),
    ranges = IRanges(c(107, 113), width = 3),
    strand = c("+", "-"), 
    score = 3:4, GC = c(0.3, 0.5))
```

The `gr1` and `gr2` are each `GRanges` objects. We can combine them into a "named"
`GRangesList` like so:

```{r example-granges-list-2}
grl <- GRangesList("txA" = gr1, "txB" = gr2)
grl
```

The `show` method for a `GRangesList` object displays it as a named list of `GRanges` objects,
where the names of this list are considered to be the names of the grouping feature. In the
example above, the groups of individual exon ranges are represented as separate `GRanges`
objects which are further organized into a list structure where each element name is a transcript
name. Many other combinations of grouped and labeled `GRanges` objects are possible
of course, but this example is a common arrangement.

In some cases, `GRangesList`s behave quite similarly to `GRanges` objects.

### Basic _GRangesList_ accessors

Just as with GRanges object, the components of the genomic coordinates within a GRangesList
object can be extracted using simple accessor methods. Not surprisingly, the GRangesList
objects have many of the same accessors as GRanges objects. The difference is that many
of these methods return a list since the input is now essentially a list of GRanges objects.
Here are a few examples:

```{r basicGRLaccessors}
seqnames(grl)
ranges(grl)
strand(grl)
```

The length and names methods will return the length or names of the list and the seqlengths
method will return the set of sequence lengths.

```{r notthesameasgranges}
length(grl)
names(grl)
seqlengths(grl)
```


## Relationships between region sets

One of the more powerful approaches to genomic data integration is to ask
about the relationship between sets of genomic ranges. The key features of 
this process are to look at overlaps and distances to the nearest feature.
These functionalities, combined with the operations like `flank` and `resize`, 
for instance, allow pretty useful analyses with relatively little code.
In general, these operations are *very* fast, even on thousands to millions
of regions. 

### Overlaps

The findOverlaps method in the GenomicRanges package is a very useful function that allows users to identify overlaps between two sets of genomic ranges.

Here's how it works:

* Inputs
  : The function requires two GRanges objects, referred to as query and subject.
* Processing
  : The function then compares every range in the query object with every range in the subject object, looking for overlaps. An overlap is defined as any instance where the range in the query object intersects with a range in the subject object.
* Output
  : The function returns a Hits (see `?Hits`) object, which is a compact representation of the matrix of overlaps. Each entry in the Hits object corresponds to a pair of overlapping ranges, with the query index and the subject index.

Here is an example of how you might use the findOverlaps function:

```{r}
# Create two GRanges objects
gr1 <- gr[1:4]
gr2 <- gr[3:8]
gr1
gr2
``` 

```{r}
# Find overlaps  
overlaps <- findOverlaps(query = gr1, subject = gr2)  
overlaps
```

In the resulting overlaps object, each row corresponds to an overlapping pair of ranges, with the first column giving the index of the range in gr1 and the second column giving the index of the overlapping range in gr2.

If you are interested in only the `queryHits` or the `subjectHits`, there are 
accessors for those (ie., `queryHits(overlaps)`). To get the actual ranges
that overlap, you can use the `subjectHits` or `queryHits` as an index into
the original `GRanges` object. 

Spend some time looking at these results. Note how the strand comes into play
when determining overlaps.

```{r}
gr1[queryHits(overlaps)]
gr2[subjectHits(overlaps)]
```

As you might expect, the `countOverlaps` method counts the regions in the
second `GRanges` that overlap with those that overlap
with each element of the first.

```{r countoverlaps}
countOverlaps(gr1, gr2)
```

The `subsetByOverlaps` method simply subsets the query `GRanges` object to include
*only* those that overlap the subject. 

```{r subsetByOverlaps}
subsetByOverlaps(gr1, gr2)
```

In some cases, you may be interested in only one hit when doing 
overlaps. Note the `select` parameter. See the help for `findOverlaps`

```{r select-first}
findOverlaps(gr1, gr2, select="first")
findOverlaps(gr1, gr2, select="first")
```

The `%over%` logical operator allows us to do similar things to 
`findOverlaps` and `subsetByOverlaps`. 

```{r}
gr2 %over% gr1
gr1[gr1 %over% gr2]
```


### Nearest feature

There are a number of useful methods that find the nearest feature (region) in a second set
for each element in the first set. 

We can review our two `GRanges` toy objects:

```{r gr-review}
g
gr
```

- nearest: Performs conventional nearest neighbor finding. Returns an integer vector containing the index of the nearest neighbor range in subject for each range in x. If there is no nearest neighbor NA is returned. For details of the algorithm see the man page in the IRanges package (?nearest).

- precede: For each range in x, precede returns the index of the range in subject that is directly preceded by the range in x. Overlapping ranges are excluded. NA is returned when there are no qualifying ranges in subject.

- follow: The opposite of precede, follow returns the index of the range in subject that is directly followed by the range in x. Overlapping ranges are excluded. NA is returned when there are no qualifying ranges in subject.

Orientation and strand for precede and follow: Orientation is 5' to 3', consistent with the direction of translation. Because positional numbering along a chromosome is from left to right and transcription takes place from 5' to 3', precede and follow can appear to have ‘opposite’ behavior on the + and - strand. Using positions 5 and 6 as an example, 5 precedes 6 on the + strand but follows 6 on the - strand.

The table below outlines the orientation when ranges on different strands are compared. In general, a feature on * is considered to belong to both strands. The single exception is when both x and subject are * in which case both are treated as +.


```
       x  |  subject  |  orientation 
     -----+-----------+----------------
a)     +  |  +        |  ---> 
b)     +  |  -        |  NA
c)     +  |  *        |  --->
d)     -  |  +        |  NA
e)     -  |  -        |  <---
f)     -  |  *        |  <---
g)     *  |  +        |  --->
h)     *  |  -        |  <---
i)     *  |  *        |  --->  (the only situation where * arbitrarily means +)
```


```{r nearest}
res = nearest(g, gr)
res
```

While `nearest` and friends give the index of the nearest feature, the distance
to the nearest is sometimes also useful to have. The `distanceToNearest`
method calculates the nearest feature as well as reporting the distance.

```{r distanceToNearest}
res = distanceToNearest(g, gr)
res
```


## Gene models

The `TxDb` package provides a convenient interface to gene models from
a variety of sources. The `TxDb.Hsapiens.UCSC.hg38.knownGene` package
provides access to the UCSC knownGene gene model for the hg19 build of
the human genome. 

![A graphical representation of range operations demonstrated on a gene model.](images/range_operations_diagram.png){#fig-range-operations}

```{r}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
```

The `transcripts` function returns a `GRanges` object with the
transcripts for all genes in the database. 

```{r}
tx <- transcripts(txdb)
```

The `exons` function returns a `GRanges` object with the exons.

```{r}
ex <- exons(txdb)
```

The `genes` function returns a `GRanges` object with the genes.

```{r}
gn <- genes(txdb)
```


## Session Info

```{r }
sessionInfo()
```



