{
  "hash": "7c61f91a39f65ab45c1bd642521e029e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Ranges Exercises\"\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show the answer\"\n    code-tools: true\n---\n\n\n\nIn the following exercises, we will use the `GenomicRanges` package to explore range operations.\nWe will use the `AnnotationHub` package to load DNAse hypersensitivity data\nfrom the ENCODE project. \nIn practice, the ENCODE project published datasets like these as bed files. \nAnnotationHub has packaged these into GRanges objects that we can load and use directly.\nHowever, if you have a bed file of your own (peak calls, enhancer regions, etc.), you can load them into GRanges objects using `rtracklayer::import`.\n\n## Exercise 1\n\nIn this exercise, we will use DNAse hypersensitivity data to practice working with a GRanges object.\n\n- Use the `AnnotationHub` package to find the `goldenpath/hg19/encodeDCC/wgEncodeUwDnase/wgEncodeUwDnaseK562PkRep1.narrowPeak.gz` `GRanges` object. Load\nthat into R as the variable dnase.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(AnnotationHub)\nah = AnnotationHub()\nquery(ah, \"goldenpath/hg19/encodeDCC/wgEncodeUwDnase/wgEncodeUwDnaseK562PkRep1.narrowPeak.gz\")\n# the thing above should have only one record, so we can \n# just grab it\ndnase = query(ah, \"goldenpath/hg19/encodeDCC/wgEncodeUwDnase/wgEncodeUwDnaseK562PkRep1.narrowPeak.gz\")[[1]]\n```\n:::\n\n\n- What type of object is dnase?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndnase\nclass(dnase)\n```\n:::\n\n\n- What metadata is stored in dnase?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcols(dnase)\n```\n:::\n\n\n- How many peaks are on each chromosome?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(GenomicFeatures)\ntable(seqnames(dnase))\n```\n:::\n\n\n- What are the mean, min, max, and median widths of the peaks?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(width(dnase))\n```\n:::\n\n\n- What are the sequences that were used in the analysis? Do the names have \"chr\" or not? Experiment with changing the\n`seqlevelsStyle` to adjust the sequence names. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseqlevels(dnase)\nseqlevelsStyle(dnase)\nseqlevelsStyle(dnase) = 'ensembl'\nseqlevelsStyle(dnase)\nseqlevels(dnase)\n```\n:::\n\n\n- What is the total amount of \"landscape\" covered by the peaks? Assume that the peaks do not overlap. What portion\nof the genome does this represent?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(width(dnase))\nsum(seqlengths(dnase))\nsum(width(dnase))/sum(seqlengths(dnase))\n```\n:::\n\n\n## Exercise 2\n\nIn this exercise, we are going to load the second DNAse hypersensitivity replicate to investigate overlaps with\nthe first replicate.\n\n- Use the AnnotationHub to find the second replicate, `goldenpath/hg19/encodeDCC/wgEncodeUwDnase/wgEncodeUwDnaseK562PkRep2.narrowPeak.gz`. Load that as `dnase2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery(ah, \"goldenpath/hg19/encodeDCC/wgEncodeUwDnase/wgEncodeUwDnaseK562PkRep2.narrowPeak.gz\")\n# the thing above should have only one record, so we can \n# just grab it\ndnase2 = query(ah, \"goldenpath/hg19/encodeDCC/wgEncodeUwDnase/wgEncodeUwDnaseK562PkRep2.narrowPeak.gz\")[[1]]\n```\n:::\n\n\n- How many peaks are there in `dnase` and `dnase2`? Are there are similar number?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(dnase)\nlength(dnase2)\n```\n:::\n\n\n- What are the peak sizes for `dnase2`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(width(dnase2))\n```\n:::\n\n\n- What proportion of the genome does `dnase2` cover?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(width(dnase))/sum(seqlengths(dnase))\n```\n:::\n\n\n- Count the number of peaks from `dnase` that overlap with `dnase2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(dnase %over% dnase2)\n```\n:::\n\n\n- Assume that your peak-caller was \"too specific\" and that you want to expand your peaks\nby 50 bp on each end (so make them 100 bp larger). Use a combination of `resize` (and pay\nattention to the `fix` argument) and `width` to do this expansion to dnase and call the\nnew `GRanges` object \"dnase_wide\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw = width(dnase)\ndnase_wide = resize(dnase, width=w+100, fix='center') #make a copy\nwidth(dnase_wide)\n```\n:::\n\n\n## Exercise 3\n\nIn this exercise, we are going to look at the overlap of DNAse sites relative to genes.\nTo get started, install and load the `TxDb.Hsapiens.UCSC.hg19.knownGene` txdb object.\n\n```\nBiocManager::install(\"TxDb.Hsapiens.UCSC.hg19.knownGene\")\nlibrary(\"TxDb.Hsapiens.UCSC.hg19.knownGene\")\nkg = TxDb.Hsapiens.UCSC.hg19.knownGene\n```\n\n- Load the transcripts from the knownGene txdb into a variable. What is the class of this object?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"TxDb.Hsapiens.UCSC.hg19.knownGene\")\nkg = TxDb.Hsapiens.UCSC.hg19.knownGene\ngx = genes(kg)\nclass(gx)\nlength(gx)\n```\n:::\n\n\n- Read about the `flank` method for GRanges objects. How could you use that to \nget the \"promoter\" regions of the transcripts? Let's assume that the promoter region is\n2kb upstream of the gene.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflank(gx,2000)\n```\n:::\n\n\n- Instead of using flank, could you do the same thing with the TxDb object? (See `?promoters`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproms = promoters(kg)\n```\n:::\n\n\n- Do any of the regions in the promoters overlap with each other? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(countOverlaps(proms))\n```\n:::\n\n\n- To find overlap of our DNAse sites with promoters, let's collapse overlapping \"promoters\" to \njust keep the contiguous regions by using `reduce`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# reduce takes all overlapping regions and collapses them\n# into a single region that spans all of the overlapping regions\nprom_regions = reduce(proms)\n\n# now we can check for overlaps\nsummary(countOverlaps(prom_regions))\n```\n:::\n\n\n- Count the number of DNAse sites that overlap with our promoter regions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(dnase %over% prom_regions)\n# if you notice no overlap, check the seqlevels\n# and seqlevelsStyle\nseqlevelsStyle(dnase) = \"UCSC\"\nsum(dnase %over% prom_regions)\nsum(dnase2 %over% prom_regions)\n```\n:::\n\n- Is this surprising? If we were to assume that the promoter and dnase regions\nare \"independent\" of each other, what number of overlaps would we expect?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop_proms = sum(width(prom_regions))/sum(seqlengths(prom_regions))\nprop_dnase = sum(width(dnase))/sum(seqlengths(prom_regions))\n# Iff the dnase and promoter regions are \n# not related, then we would expect this number\n# of DNAse overlaps with promoters.\nprop_proms * prop_dnase * length(dnase) \n```\n:::\n\n\n## Exercise 4\n\nWe'll be using data from histone modification ChIP-seq experiments in human cells to illustrate the concepts of genomic ranges and features. The data consists of genomic intervals representing regions of the genome where specific histone modifications are enriched. These intervals are typically identified using ChIP-seq, a technique that maps protein-DNA interactions across the genome.\n\nThe ChIP-seq data is stored in a BED file format, which is a tab-delimited text file format commonly used to represent genomic intervals. Each line in the BED file corresponds to a genomic interval and contains information about the chromosome, start and end positions, and strand orientation of the interval. Additional columns may include metadata such as the signal strength or significance of the interval.\n\nThe AnnotationHub package in Bioconductor provides access to a wide range of genomic datasets, including ChIP-seq data. We can use this package to retrieve the ChIP-seq data for histone modifications in human cells and convert it into a GenomicRanges object for further analysis.\n\n<https://www.encodeproject.org/chip-seq/histone/>\n\nLet's start by loading the AnnotationHub package and retrieving the ChIP-seq data for histone modifications in human cells. You can read more about the AnnotationHub package and how to use it in the Bioconductor documentation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(AnnotationHub)\nah <- AnnotationHub()\n```\n:::\n\n\nThere are multiple ways to search the AnnotationHub database. \nWe've done that for you and here are the `GRanges` objects for each of four histone marks, and one histone mark replicate. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nh3k4me1 <- ah[['AH25832']]\nh3k4me3 <- ah[['AH25833']]\nh3k9ac <- ah[['AH25834']]\nh3k27me3 <- ah[['AH25835']]\nh3k4me3_2 <- ah[['AH27284']]\n```\n:::\n\n\n\nEach of these variables now represents the peak calls after a chip-seq experiment pulling down the histone mark of interest. \nIn the encode project these records were `bed` files. \nThe bed files have been converted to `GRanges` objects to allow computation within R. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grab cpg islands as well\ncpg = query(ah, c('cpg','UCSC','hg19'))[[1]]\n```\n:::\n\n\nLet's say that we don't know the behavior of the histone methylation marks with respect to CpG islands. \nWe could ask the question, \"What is the overlap of the histone peaks with CpG islands?\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(h3k4me1 %over% cpg)\n```\n:::\n\n\nWe might want to actually count the number of bases of overlap between the methyl mark and CpG islands.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The intersection of two peak sets results in the \n# overlapping regions as a new set of regions\n# The width of each peak is the number of overlapping bases\n# And the sum of the widths is the total bases overlapping\nsum(width(intersect(h3k4me1, cpg)))\n```\n:::\n\n\nBut some methyl marks are known to have very broad signals, meaning that there is a higher chance of overlapping CpG islands just because there are more methylated bases.\nWe can adjust for this by \"normalizing\" for all possible bases covered by either set of peaks, using `union`.\nWe might think of this as a sort of \"enrichment score\" of one set in another set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(width(union(h3k4me1, cpg)))\n# and now \"normalize\" \nsum(width(intersect(h3k4me1, cpg)))/sum(width(union(h3k4me1, cpg)))\n```\n:::\n\n\nLet's write a small function to calculate our little enrichment score.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange_enrichment_score <- function(r1, r2) {\n  i = sum(width(intersect(r1, r2)))\n  u = sum(width(union(r1,r2)))\n  return(i/u)\n}\n```\n:::\n\n\nAnd give it a try:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange_enrichment_score(h3k4me1, cpg)\n```\n:::\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}