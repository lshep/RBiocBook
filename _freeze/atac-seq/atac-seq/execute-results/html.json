{
  "hash": "82e61a5895cfee134c18afad0b2982d9",
  "result": {
    "engine": "knitr",
    "markdown": "---\nbibliography: atac.bib\nlink-citations: true\n---\n\n# Genomic ranges and ATAC-Seq\n\n\n\n## _R_ / _Bioconductor_ packages used {.unnumbered}\n\n- *[Rsamtools](https://bioconductor.org/packages/3.20/Rsamtools)*  \n- *[GenomicRanges](https://bioconductor.org/packages/3.20/GenomicRanges)*  \n- *[GenomicFeatures](https://bioconductor.org/packages/3.20/GenomicFeatures)*  \n- *[GenomicAlignments](https://bioconductor.org/packages/3.20/GenomicAlignments)* \n- *[rtracklayer](https://bioconductor.org/packages/3.20/rtracklayer)* \n- *[heatmaps](https://bioconductor.org/packages/3.20/heatmaps)*\n\n## Background \n\nChromatin accessibility assays measure the extent to which DNA is open and accessible.\nSuch assays now use high throughput sequencing as a quantitative readout. DNAse assays, first using microarrays[@Crawford2006-nt] and then DNAse-Seq [@Crawford2006-bk], requires a larger amount of DNA and is labor-indensive and has been largely supplanted by ATAC-Seq [@Buenrostro2013-dz]. \n\nThe Assay for Transposase Accessible Chromatin with high-throughput sequencing (ATAC-seq) method maps chromatin accessibility genome-wide. This method quantifies DNA accessibility with a hyperactive Tn5 transposase that cuts and inserts sequencing adapters into regions of chromatin that are accessible. High throughput sequencing of fragments produced by the process map to regions of increased accessibility, transcription factor binding sites, and nucleosome positioning. The method is both fast and sensitive and can be used as a replacement for DNAse _and_ MNase. \n\n\nAn early review of chromatin accessibility assays [@Tsompana2014-yh] compares the use cases, pros and cons, and expected signals from each of the most common approaches (Figure \\@ref(fig:chromatinAssays)).\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Chromatin accessibility methods, compared. Representative DNA fragments generated by each assay are shown, with end locations within chromatin defined by colored arrows. Bar diagrams represent data signal obtained from each assay across the entire region. The footprint created by a transcription factor (TF) is shown for ATAC-seq and DNase-seq experiments.](imgs/chromatin_accessibility_buck.png){width=808}\n:::\n:::\n\n\nThe first manuscript describing ATAC-Seq protocol and findings outlined how ATAC-Seq data \"line up\" with other datatypes such as ChIP-seq and DNAse-seq (Figure \\@ref(fig:greenleaf)). They also highlight how fragment length correlates with specific genomic regions and characteristics [@Buenrostro2013-dz, Figure 3].\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Multimodal chromatin comparisons. From [@Buenrostro2013-dz], Figure 4. (a) CTCF footprints observed in ATAC-seq and DNase-seq data, at a specific locus on chr1. (b) Aggregate ATAC-seq footprint for CTCF (motif shown) generated over binding sites within the genome (c) CTCF predicted binding probability inferred from ATAC-seq data, position weight matrix (PWM) scores for the CTCF motif, and evolutionary conservation (PhyloP). Right-most column is the CTCF ChIP-seq data (ENCODE) for this GM12878 cell line, demonstrating high concordance with predicted binding probability.](imgs/greenleaf_chip_dnase_atac.png){width=836}\n:::\n:::\n\n\nBuenrostro et al. provide a detailed protocol for performing ATAC-Seq and quality control of results [@Buenrostro2015-dz]. Updated and modified protocols that improve on signal-to-noise and reduce input DNA requirements have been described.\n\n## Informatics overview\n\nATAC-Seq protocols typically utilize paired-end sequencing protocols. The reads are aligned to the respective _genome_ using `bowtie2`, `BWA`, or other short-read aligner. The result, after appropriate manipulation, often using `samtools`, results in a BAM file. Among other details, the BAM format includes columns for:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::include_graphics('imgs/bam_shot.png')\n```\n\n::: {.cell-output-display}\n![A BAM file in text form. The output of `samtools view` is the text format of the BAM file (called SAM format). Bioconductor and many other tools use BAM files for input. Note that BAM files also often include an index `.bai` file that enables random access into the file; one can read just a genomic region without having to read the entire file.](imgs/bam_shot.png){width=1126}\n:::\n:::\n\n\n- sequence name (`chr1`)\n- start position (integer)\n- a _CIGAR_ string that describes the alignment in a compact form\n- the sequence to which the pair aligns\n- the position to which the pair aligns\n- a bit flag field that describes multiple characteristics of the alignment\n- the sequence and quality string of the read\n- additional tags that tend to be aligner-specific\n\n\nDuplicate fragments (those with the *same* start and end position of other reads) are marked and likely discarded. Reads that fail to align \"properly\" are also often excluded from analysis. It is worth noting that most software packages allow simple \"marking\" of such reads and that there is usually no need to create a special BAM file before proceeding with downstream work. \n\nAfter alignment and BAM processing, the workflow can switch to _Bioconductor_. \n\n## Working with sequencing data in Bioconductor\n\nThe _Bioconductor_ project includes several infrastructure packages for dealing with ranges (sequence name, start, end, +/- strand) on sequences [@Lawrence2013-he] as well as capabilities with working with Fastq files directly [@morgan2016rsamtools].\n\n| Package  | Use cases |\n|---|---|\n| *[Rsamtools](https://bioconductor.org/packages/3.20/Rsamtools)*  | low level access to FASTQ, VCF, SAM, BAM, BCF formats   |\n| *[GenomicRanges](https://bioconductor.org/packages/3.20/GenomicRanges)*  | Container and methods for handling genomic reagions   |\n| *[GenomicFeatures](https://bioconductor.org/packages/3.20/GenomicFeatures)*  | Work with transcript databases, gff, gtf and BED formats  |\n| *[GenomicAlignments](https://bioconductor.org/packages/3.20/GenomicAlignments)* | Reader for BAM format |\n| *[rtracklayer](https://bioconductor.org/packages/3.20/rtracklayer)* | import and export multiple UCSC file formats including BigWig and Bed |\n\nTable: Commonly used Bioconductor and their high-level use cases.\n\nAs noted in the previous section, the output of an ATAC-Seq experiment is a BAM file. \nAs paired-end sequencing is a commonly-applied approach for ATAC-Seq, the `readGAlignmentPairs` function\nis the appropriate method to use. \n\n# Data import and quality control\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(GenomicAlignments)\n```\n:::\n\n\nReading a paired-end BAM file looks a bit complicated, but the following code will:\n\n1. Read the included BAM file.\n2. Include read pairs only (`isPaired = TRUE`)\n3. Include properly paired reads (`isProperPair = TRUE`)\n4. Include reads with mapping quality >= 1\n5. Add a couple of additional fields, `mapq` (mapping quality) and `isize` (insert size) to the default fields. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreenleaf <- readGAlignmentPairs(\n    \"https://github.com/seandavi/RBiocBook/raw/main/atac-seq/extdata/Sorted_ATAC_21_22.bam\",\n    param = ScanBamParam(\n        mapqFilter = 1,\n        flag = scanBamFlag(\n            isPaired = TRUE,\n            isProperPair = TRUE\n        ),\n        what = c(\"mapq\", \"isize\")\n    )\n)\n```\n:::\n\n\n*Exercise*: What is the class of `greenleaf`?\n*Exercise*: Use the `GenomicAlignments::first()` accessor to get the first read of the pair as a `GAlignments` object. Save the result as a variable called `gl_first_read`. Use the `mcols` accessor to find the \"metadata columns\" of `gl_first_read`.\n*Exercise*: How many read pairs map to each chromosome? \n\n\nWe can make plot of the number of reads mapping to each chromosome. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nchromCounts <- table(seqnames(greenleaf)) %>%\n    data.frame() %>%\n    dplyr::rename(chromosome = Var1, count = Freq)\n```\n:::\n\n\nTo keep things small, the example BAM file includes only chromosomes 21 and 22. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(chromCounts, aes(x = chromosome, y = count)) +\n    geom_bar(stat = \"identity\") +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![Reads per chromosome. In our example data, we are using only chromosomes 21 and 22.](atac-seq_files/figure-html/plotChromCounts-1.png){width=672}\n:::\n:::\n\n\nNormalizing by the chromosome length can yield the reads per megabase which should crudely be similar across all chromosomes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchromCounts <- chromCounts %>%\n    dplyr::mutate(readsPerMb = (count / (seqlengths(greenleaf) / 1e6)))\n```\n:::\n\n\n\nAnd show a plot. For two chromosomes, this is a little underwhelming. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(chromCounts, aes(x = chromosome, y = readsPerMb)) +\n    geom_bar(stat = \"identity\") +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![Read counts normalized by chromosome length. This is not a particularly important plot, but it can be useful to see the relative contribution of each chromosome given its length.](atac-seq_files/figure-html/plotReadProps-1.png){width=672}\n:::\n:::\n\n\n## Coverage\n\nThe `coverage` method for genomic ranges calculates, for each base, the number of overlapping features. In the case of a BAM file from ATAC-Seq converted to a GAlignmentPairs object, the coverage gives us an idea of the extent to which reads pile up to form peaks. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncvg <- coverage(greenleaf)\nclass(cvg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SimpleRleList\"\nattr(,\"package\")\n[1] \"IRanges\"\n```\n\n\n:::\n:::\n\n\nThe coverage is returned as a `SimpleRleList` object. Using `names` can get us the names of the elements of the list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(cvg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"chr1\"  \"chr2\"  \"chr3\"  \"chr4\"  \"chr5\"  \"chr6\"  \"chr7\"  \"chr8\"  \"chr9\" \n[10] \"chr10\" \"chr11\" \"chr12\" \"chr13\" \"chr14\" \"chr15\" \"chr16\" \"chr17\" \"chr18\"\n[19] \"chr19\" \"chr20\" \"chr21\" \"chr22\" \"chrX\"  \"chrY\"  \"chrM\" \n```\n\n\n:::\n:::\n\n\nThere is a name for each chromosome. Looking at the `chr21` entry:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncvg$chr21\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ninteger-Rle of length 48129895 with 397462 runs\n  Lengths: 9411376      50      11      50 ...      36      14      28   10806\n  Values :       0       2       0       2 ...       1       2       1       0\n```\n\n\n:::\n:::\n\n\nwe see that each chromosome is represented as an `Rle`, short for run-length-encoding. Simply put, since along the chromosome there are many repeated values, we can recode the long vector as a set of (length: value) pairs. For example, if the first 9,410,000 base pairs have `0` coverage, we encode that as (9,410,000: 0). Doing that across the chromosome can very significantly reduce the memory use for genomic coverage. \n\nThe following little function, `plotCvgHistByChrom` can plot a histogram of the coverage for a chromosome. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotCvgHistByChrom <- function(cvg, chromosome) {\n    library(ggplot2)\n    cvgcounts <- as.data.frame(table(cvg[[chromosome]]))\n    cvgcounts[, 1] <- as.numeric(as.character(cvgcounts[, 1]))\n    colnames(cvgcounts) <- c(\"Coverage\", \"Count\")\n    ggplot(cvgcounts, aes(x = Coverage, y = Count)) +\n        ggtitle(paste(\"Chromosome\", chromosome)) +\n        geom_point(alpha = 0.5) +\n        geom_smooth(span = 0.2) +\n        scale_y_log10() +\n        theme_bw()\n}\nfor (i in c(\"chr21\", \"chr22\")) {\n    print(plotCvgHistByChrom(cvg, i))\n}\n```\n\n::: {.cell-output-display}\n![](atac-seq_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](atac-seq_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n:::\n\n\n## Fragment Lengths\n\nThe first ATAC-Seq manuscript [@Buenrostro2013-dz] highlighted the relationship between fragment length and nucleosomes (see Figure \\@ref{fig:flgreenleaf}).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::include_graphics(\"https://cdn.ncbi.nlm.nih.gov/pmc/blobs/0ad9/3959825/fde39a9fb288/nihms554473f2.jpg\")\n```\n\n::: {.cell-output-display}\n![Relationship between fragment length and nucleosome number.](https://cdn.ncbi.nlm.nih.gov/pmc/blobs/0ad9/3959825/fde39a9fb288/nihms554473f2.jpg)\n:::\n:::\n\n\nRemember that we loaded the example BAM file with insert sizes (`isize`). We can use that \"column\" to examine the fragment lengths (another name for insert size). Also, note that the insert size for the `first` read and the `second` are the same (absolute value). Here, we will use `first`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGenomicAlignments::first(greenleaf)\nmcols(GenomicAlignments::first(greenleaf))\nclass(mcols(GenomicAlignments::first(greenleaf)))\nhead(mcols(GenomicAlignments::first(greenleaf))$isize)\nfraglengths <- abs(mcols(GenomicAlignments::first(greenleaf))$isize)\n```\n:::\n\n\nWe can plot the fragment length density (histogram) using the `density` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(density(fraglengths, bw = 0.05), xlim = c(0, 1000))\n```\n\n::: {.cell-output-display}\n![Fragment length histogram. ](atac-seq_files/figure-html/fraglength-1.png){width=672}\n:::\n:::\n\n\nAnd for fun, the ggplot2 version:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\nfragLenPlot <- table(fraglengths) %>%\n    data.frame() |>\n    rename(\n        InsertSize = fraglengths,\n        Count = Freq\n    ) |>\n    mutate(\n        InsertSize = as.numeric(as.vector(InsertSize)),\n        Count = as.numeric(as.vector(Count))\n    ) |>\n    ggplot(aes(x = InsertSize, y = Count)) +\n    geom_line()\nprint(fragLenPlot + theme_bw() + lims(x = c(-1, 500)))\n```\n\n::: {.cell-output-display}\n![](atac-seq_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nKnowing that the nucleosome-free regions will have insert sizes shorter than one nucleosome, we can isolate the read pairs that have that characteristic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngl_nf <- greenleaf[mcols(GenomicAlignments::first(greenleaf))$isize < 100]\n```\n:::\n\n\nAnd the mononucleosome reads will be between 187 and 250 base pairs for insert size/fragment length.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngl_mn <- greenleaf[mcols(GenomicAlignments::first(greenleaf))$isize > 187 &\n    mcols(GenomicAlignments::first(greenleaf))$isize < 250]\n```\n:::\n\n\nFinally, we expect nucleosome-free reads to be enriched near the TSS while mononucleosome reads should not be. We will use the *[heatmaps](https://bioconductor.org/packages/3.20/heatmaps)* package to take a look at these two sets of reads with respect to the tss of the human genome.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\nproms <- promoters(TxDb.Hsapiens.UCSC.hg19.knownGene, 250, 250)\nseqs <- c(\"chr21\", \"chr22\")\nseqlevels(proms, pruning.mode = \"coarse\") <- seqs # only chromosome 21 and 22\n```\n:::\n\n\nTake a look at the *[heatmaps](https://bioconductor.org/packages/3.20/heatmaps)* package vignette to learn more about the heatmaps package capabilities.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(heatmaps)\ngl_nf_hm <- CoverageHeatmap(proms, coverage(gl_nf), coords = c(-250, 250))\nlabel(gl_nf_hm) <- \"NucFree\"\nscale(gl_nf_hm) <- c(0, 10)\nplotHeatmapMeta(gl_nf_hm)\n```\n\n::: {.cell-output-display}\n![Enrichment of nucleosome free reads just upstream of the TSS.](atac-seq_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngl_mn_hm <- CoverageHeatmap(proms, coverage(gl_mn), coords = c(-250, 250))\nlabel(gl_mn_hm) <- \"MonoNuc\"\nscale(gl_mn_hm) <- c(0, 10)\nplotHeatmapMeta(gl_mn_hm)\n```\n\n::: {.cell-output-display}\n![Depletion of nucleosome free reads just upstream of the TSS.](atac-seq_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotHeatmapList(list(gl_mn_hm, gl_nf_hm))\n```\n\n::: {.cell-output-display}\n![Comparison of signals at TSS. Mononucleosome data on the left, nucleosome-free on the right.](atac-seq_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n## Viewing data in IGV\n\nInstall IGV from [here](https://software.broadinstitute.org/software/igv/download).\n\nWe export the greenleaf data as a BigWig file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rtracklayer)\nexport.bw(coverage(greenleaf), \"greenleaf.bw\")\n```\n:::\n\n\n- *Exercise*: In IGV, choose `hg19`. Then, load the `greenleaf.bw` file and explore chromosomes 21 and 22. \n- *Exercise*: Export the nucleosome-free portion of the data as a BigWig file and examine that in IGV. Where do you expect to see the strongest signals? \n\n## Additional work\n\nFor those working extensively on ATAC-Seq, there is a great workflow/tutorial available from Thomas Carrol:\n\n- <https://rockefelleruniversity.github.io/RU_ATAC_Workshop.html>\n\nFeel free to work through it. In addition to the work above, there is also the *[ATACseqQC](https://bioconductor.org/packages/3.20/ATACseqQC)* package vignette that offers more than just QC. At least a couple more packages are available in _Bioconductor_.\n\n\n## MACS2 {.unnumbered}\n\nThe MACS2 package is a commonly-used package for calling peaks. Installation\nand other details are available[^macs].\n\n[^macs]: https://github.com/taoliu/MACS\n\n```\npip install macs2\n```\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}