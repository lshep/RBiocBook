{
  "hash": "c1bd70c8ca20598f927250b0102dd0ae",
  "result": {
    "engine": "knitr",
    "markdown": "# Matrices\n\nA _matrix_ is a rectangular collection of the same data type (see @fig-datastructures_schematic). It can be viewed\nas a collection of column vectors all of the same length and the same type\n(i.e. numeric, character or logical) OR a collection of row vectors, again all\nof the same type and length. A _data.frame_ is *also* a rectangular array. All\nof the columns must be the same length, but they **may be** of *different* types.\nThe rows and columns of a matrix or data frame can be given names. However\nthese are implemented differently in R; many operations will work for one but\nnot both, often a source of confusion.\n\n![A matrix is a collection of column vectors.](images/datastructures_schematic.png){#fig-datastructures_schematic}\n\n\n## Creating a matrix\n\nThere are many ways to create a matrix in R. One of the simplest is to use the\n`matrix()` function. In the code below, we'll create a matrix from a vector\nfrom 1:16.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n```\n\n\n:::\n:::\n\n\nThe same is possible, but specifying that the matrix be \"filled\" by row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4,byrow = TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n```\n\n\n:::\n:::\n\n\nNotice the subtle difference in the order that the numbers go into the matrix.\n\n\nWe can also build a matrix from parts by \"binding\" vectors together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10 \ny <- rnorm(10)\n```\n:::\n\n\nEach of the vectors above is of length 10 and both are \"numeric\", so we can make\nthem into a matrix. Using `rbind` binds rows (**r**) into a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- rbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1]       [,2]      [,3]      [,4]      [,5]       [,6]        [,7]\nx  1.000000  2.0000000 3.0000000 4.0000000 5.0000000  6.0000000 7.000000000\ny -1.228773 -0.2758345 0.4839539 0.6852573 0.2203544 -0.8918151 0.001942281\n      [,8]      [,9]     [,10]\nx 8.000000  9.000000 10.000000\ny 0.757714 -1.669156 -2.116421\n```\n\n\n:::\n:::\n\n\nThe alternative to `rbind` is `cbind` that binds columns (**c**) together. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- cbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x            y\n [1,]  1 -1.228773410\n [2,]  2 -0.275834474\n [3,]  3  0.483953917\n [4,]  4  0.685257349\n [5,]  5  0.220354435\n [6,]  6 -0.891815131\n [7,]  7  0.001942281\n [8,]  8  0.757713993\n [9,]  9 -1.669155965\n[10,] 10 -2.116420993\n```\n\n\n:::\n:::\n\n\nInspecting the names associated with rows and columns is often useful,\nparticularly if the names have human meaning. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\nWe can also change the names of the matrix by assigning _valid_ names to the \ncolumns or rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mat) = c('apples','oranges')\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apples\"  \"oranges\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      apples      oranges\n [1,]      1 -1.228773410\n [2,]      2 -0.275834474\n [3,]      3  0.483953917\n [4,]      4  0.685257349\n [5,]      5  0.220354435\n [6,]      6 -0.891815131\n [7,]      7  0.001942281\n [8,]      8  0.757713993\n [9,]      9 -1.669155965\n[10,]     10 -2.116420993\n```\n\n\n:::\n:::\n\n\n\n\nMatrices have dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  2\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n## Accessing elements of a matrix\n\nIndexing for matrices works as for vectors except that we now need to\ninclude both the row and column (in that order). We can access elements \nof a matrix using the square bracket [ indexing method. Elements can be \naccessed as `var[r, c]`. Here, `r` and `c` are vectors describing the elements\nof the matrix to select.\n\n::: {.callout-important}\nThe indices in R start with one, meaning that the first element of a vector or the first row/column of a matrix is indexed as one.\n\nThis is different from some other programming languages, such as Python, which use zero-based indexing, meaning that the first element of a vector or the first row/column of a matrix is indexed as zero.\n\nIt is important to be aware of this difference when working with data in R, especially if you are coming from a programming background that uses zero-based indexing. Using the wrong index can lead to unexpected results or errors in your code.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The 2nd element of the 1st row of mat\nmat[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  oranges \n-1.228773 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first ROW of mat\nmat[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   apples   oranges \n 1.000000 -1.228773 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first COLUMN of mat\nmat[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# and all elements of mat that are > 4; note no comma\nmat[mat>4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n## [1]  5  6  7  8  9 10\n```\n:::\n\n\n::: {.callout-caution}\nNote that in the last case, there is no \",\", so R treats the matrix as a long \nvector (length=20). This is convenient, sometimes, but it can also be a source \nof error, as some code may \"work\" but be doing something unexpected.\n\n:::\n\n\n\nWe can also use indexing to exclude a row or column by prefixing the selection\nwith a `-` sign.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[,-1]       # remove first column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -1.228773410 -0.275834474  0.483953917  0.685257349  0.220354435\n [6] -0.891815131  0.001942281  0.757713993 -1.669155965 -2.116420993\n```\n\n\n:::\n\n```{.r .cell-code}\nmat[-c(1:5),]  # remove first five rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     apples      oranges\n[1,]      6 -0.891815131\n[2,]      7  0.001942281\n[3,]      8  0.757713993\n[4,]      9 -1.669155965\n[5,]     10 -2.116420993\n```\n\n\n:::\n:::\n\n\n## Changing values in a matrix\n\nWe can create a matrix filled with random values drawn from a normal\ndistribution for our work below. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = matrix(rnorm(20),nrow=10)\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                V2          \n Min.   :-2.3145   Min.   :-0.84195  \n 1st Qu.:-0.7889   1st Qu.: 0.05582  \n Median :-0.3123   Median : 0.66601  \n Mean   :-0.4460   Mean   : 0.49552  \n 3rd Qu.: 0.2631   3rd Qu.: 0.88635  \n Max.   : 0.8091   Max.   : 1.57845  \n```\n\n\n:::\n:::\n\n\nMultiplication and division works similarly to vectors. When multiplying by a \nvector, for example, the values of the vector are reused. In the simplest case, \nlet's multiply the matrix by a constant (vector of length 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# multiply all values in the matrix by 20\nm2 = m*20\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                V2         \n Min.   :-46.290   Min.   :-16.839  \n 1st Qu.:-15.779   1st Qu.:  1.116  \n Median : -6.245   Median : 13.320  \n Mean   : -8.919   Mean   :  9.910  \n 3rd Qu.:  5.263   3rd Qu.: 17.727  \n Max.   : 16.182   Max.   : 31.569  \n```\n\n\n:::\n:::\n\n\nBy combining subsetting with assignment, we can make changes to just part of a \nmatrix. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# and add 100 to the first column of m\nm2[,1] = m2[,1] + 100\n# summarize m\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1               V2         \n Min.   : 53.71   Min.   :-16.839  \n 1st Qu.: 84.22   1st Qu.:  1.116  \n Median : 93.75   Median : 13.320  \n Mean   : 91.08   Mean   :  9.910  \n 3rd Qu.:105.26   3rd Qu.: 17.727  \n Max.   :116.18   Max.   : 31.569  \n```\n\n\n:::\n:::\n\n\nA somewhat common transformation for a matrix is to transpose which changes\nrows to columns. One might need to do this if an assay output from a lab \nmachine puts samples in rows and genes in columns, for example, while in \nBioconductor/R, we often want the samples in columns and the genes in rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]      [,2]      [,3]     [,4]      [,5]     [,6]      [,7]\n[1,] 106.51366 88.205812 116.18173 91.66361 101.50959 95.84575  63.39978\n[2,]  15.64551 -6.769123  31.56894 10.99492  17.05706 17.95023 -16.83897\n          [,8]       [,9]     [,10]\n[1,] 53.710329 82.8932539 110.88171\n[2,]  2.963153  0.5008467  26.03196\n```\n\n\n:::\n:::\n\n\n## Calculations on matrix rows and columns\n\nAgain, we just need a matrix to play with. We'll use `rnorm` again, but with a\nslight twist. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3 = matrix(rnorm(100,5,2),ncol=10) # what does the 5 mean here? And the 2?\n```\n:::\n\n\nSince these data are from a normal distribution, we can look at a row (or column)\nto see what the mean and standard deviation are.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.369992\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.587709\n```\n\n\n:::\n\n```{.r .cell-code}\n# or a row\nmean(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.8476\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.895771\n```\n\n\n:::\n:::\n\n\nThere are some useful convenience functions for computing means and sums \nof data in **all** of the columns and rows of matrices. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 4.369992 5.047730 4.991333 5.002943 5.071057 5.146604 5.526883 4.841773\n [9] 4.710269 5.202923\n```\n\n\n:::\n\n```{.r .cell-code}\nrowMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 4.847600 5.397351 4.586643 4.571248 4.324695 5.030387 5.275307 6.082925\n [9] 4.805262 4.990090\n```\n\n\n:::\n\n```{.r .cell-code}\nrowSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 48.47600 53.97351 45.86643 45.71248 43.24695 50.30387 52.75307 60.82925\n [9] 48.05262 49.90090\n```\n\n\n:::\n\n```{.r .cell-code}\ncolSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 43.69992 50.47730 49.91333 50.02943 50.71057 51.46604 55.26883 48.41773\n [9] 47.10269 52.02923\n```\n\n\n:::\n:::\n\n\nWe can look at the distribution of column means:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save as a variable\ncmeans = colMeans(m3)\nsummary(cmeans)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.370   4.879   5.025   4.991   5.128   5.527 \n```\n\n\n:::\n:::\n\nNote that this is centered pretty closely around the selected mean of `5` above.\n\nHow about the standard deviation? There is not a `colSd` function, but it turns\nout that we can easily apply functions that take vectors as input, like `sd` and\n\"apply\" them across either the rows (the first dimension) or columns (the second)\ndimension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsds = apply(m3, 2, sd)\nsummary(csds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.094   1.477   1.749   1.781   1.884   2.588 \n```\n\n\n:::\n:::\n\n\nAgain, take a look at the distribution which is centered quite close to the \nselected standard deviation when we created our matrix.\n\n\n## Exercises\n\n\n\n\n### Data preparation\n\nFor this set of exercises, we are going to rely on a dataset that comes with R.\nIt gives the number of sunspots per month from 1749-1983. The dataset comes as \na `ts` or time series data type which I convert to a matrix using the following\ncode. \n\nJust run the code as is and focus on the rest of the exercises. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(sunspots)\nsunspot_mat <- matrix(as.vector(sunspots),ncol=12,byrow = TRUE)\ncolnames(sunspot_mat) <- as.character(1:12)\nrownames(sunspot_mat) <- as.character(1749:1983)\n```\n:::\n\n\n### Questions\n\n-   After the conversion above, what does `sunspot_mat` look like? Use functions\nto find the number of rows, the number of columns, the class, and some basic\nsummary statistics.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ncol(sunspot_mat)\n    nrow(sunspot_mat)\n    dim(sunspot_mat)\n    summary(sunspot_mat)\n    head(sunspot_mat)\n    tail(sunspot_mat)\n    ```\n    :::\n\n\n\n-   Practice subsetting the matrix a bit by selecting:\n    - The first 10 years (rows)\n    - The month of July (7th column)\n    - The value for July, 1979 using the rowname to do the selection.\n  \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    sunspot_mat[1:10,]\n    sunspot_mat[,7]\n    sunspot_mat['1979',7]\n    ```\n    :::\n\n\n\n1.  These next few exercises take advantage of the fact that calling a univariate\nstatistical function (one that expects a vector) works for matrices by just making\na vector of all the values in the matrix. \nWhat is the highest (max) number of sunspots recorded in these data?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    max(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the minimum?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    min(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the overall mean and median?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    mean(sunspot_mat)\n    median(sunspot_mat)\n    ```\n    :::\n\n\n1.  Use the `hist()` function to look at the distribution of all the monthly \nsunspot data. \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat)\n    ```\n    :::\n\n1.  Read about the `breaks` argument to `hist()` to try to increase the number of\nbreaks in the histogram to increase the resolution slightly. Adjust your `hist()`\nand breaks to your liking.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat, breaks=40)\n    ```\n    :::\n\n\n\n1.  Now, let's move on to summarizing the data a bit to learn about the pattern of \nsunspots varies by month or by year. Examine the dataset again. What do the\ncolumns represent? And the rows?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # just a quick glimpse of the data will give us a sense\n    head(sunspot_mat)\n    ```\n    :::\n\n\n1.  We'd like to look at the distribution of sunspots by month. How can we do that?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # the mean of the columns is the mean number of sunspots per month.\n    colMeans(sunspot_mat)\n    \n    # Another way to write the same thing:\n    apply(sunspot_mat, 2, mean)\n    ```\n    :::\n\n1.  Assign the month summary above to a variable and summarize it to get a sense\nof the spread over months.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    monthmeans = colMeans(sunspot_mat)\n    summary(monthmeans)\n    ```\n    :::\n\n\n1.  Play the same game for years to get the per-year mean?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ymeans = rowMeans(sunspot_mat)\n    summary(ymeans)\n    ```\n    :::\n\n\n1.  Make a plot of the yearly means. Do you see a pattern?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    plot(ymeans)\n    # or make it clearer\n    plot(ymeans, type='l')\n    ```\n    :::\n\n\n\n\n\n\n\n",
    "supporting": [
      "matrices_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}