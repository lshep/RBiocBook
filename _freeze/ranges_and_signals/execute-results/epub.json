{
  "hash": "e65e6cffe8c906216ff7b8c5e155a23c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Genomic ranges and features\"\noutput: \n  html_document\n---\n\n\n\n## Introduction\n\nGenomic ranges are essential components in the field of genomics, representing intervals on the genome that specify the start and end positions of DNA segments. These ranges can denote various genomic features, such as genes, exons, regulatory elements, and regions identified in genomic studies like ChIP-seq peaks. They play a pivotal role in the annotation, comparison, and interpretation of genomic features and experimental data, making them indispensable in biological data analysis.\n\nUnderstanding genomic ranges begins with the concept of coordinate systems. Different databases and tools adopt different conventions for indexing genomic coordinates. For instance, the UCSC Genome Browser uses a 0-based coordinate system, while Ensembl employs a 1-based system. Moreover, genomic ranges often include strand information, indicating whether the feature is on the positive or negative DNA strand, which is crucial for correctly interpreting gene expression and other genomic functions.\n\nGenomic ranges come in various forms, from single ranges defined by a simple start and end position (such as a single exon) to complex multi-range sets encompassing collections of ranges like all exons of a gene. Manipulating these ranges involves several fundamental operations. Intersection allows researchers to find overlapping regions between two sets of ranges, such as identifying ChIP-seq peaks that overlap with promoter regions. Union operations combine multiple ranges into a single contiguous range, while set difference identifies regions in one set that do not overlap with another set.\n\nSeveral tools and libraries have been developed to facilitate the manipulation of genomic ranges. In the R programming environment, the Bioconductor project provides the GenomicRanges package, which is specifically designed for representing and manipulating genomic ranges. This package offers a variety of functions for range arithmetic and efficient overlap queries. Another useful R package is rtracklayer, which enables the import and export of genomic data in various formats, including BED and GFF files.\n\nFor those who prefer a command-line interface, BEDTools offers a suite of utilities for performing a wide range of operations on genomic intervals. This toolset is highly versatile, supporting tasks like intersecting, merging, and complementing genomic intervals. In the Python ecosystem, PyRanges provides a fast and flexible library for manipulating genomic intervals, offering similar functionality to Bioconductor’s GenomicRanges.\n\nThe applications of genomic ranges are diverse and far-reaching. In gene annotation, for instance, RNA-seq reads are mapped to known gene models to quantify gene expression levels. Variant annotation involves mapping variants identified from sequencing data to their genomic context, predicting functional consequences based on their location within genes or intergenic regions. Comparative genomics leverages genomic ranges to compare intervals between species, identifying conserved regions that might indicate essential functional elements. Epigenomic studies utilize genomic ranges to intersect DNA methylation data or histone modification peaks with genomic features, providing insights into regulatory mechanisms.\n\nDespite their utility, working with genomic ranges presents several challenges. Converting coordinates between different reference genomes or different versions of the same genome can be complex and prone to errors. Integrating diverse types of genomic data, such as DNA sequences, epigenetic marks, and RNA-seq data, requires meticulous handling of genomic coordinates and ranges to ensure accurate analyses. Moreover, the sheer scale of genomic data necessitates optimized algorithms and data structures to handle large datasets efficiently.\n\nInterpreting genomic ranges within their biological context is crucial for drawing meaningful conclusions. For instance, a range within a gene’s promoter region might indicate potential regulatory activity. Understanding the functional implications of genomic ranges often involves overlapping these ranges with known functional elements, such as enhancers or silencers, to infer gene regulation mechanisms and their phenotypic consequences. Tools like the UCSC Genome Browser and the Integrative Genomics Viewer (IGV) are invaluable for visualizing genomic ranges alongside other genomic annotations, aiding in the interpretation and exploration of genomic data.\n\n## Bioconductor and GenomicRanges\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(GenomicRanges)\n```\n:::\n\nThe Bioconductor [`GenomicRanges`](http://bioconductor.org/packages/GenomicRanges.html) package is a comprehensive toolkit designed to handle and manipulate genomic intervals and variables systematized on these intervals [@lawrence_software_2013]. Developed by Bioconductor, this package simplifies the complexity of managing genomic data, facilitating the efficient exploration, manipulation, and visualization of such data. GenomicRanges aids in dealing with the challenges of genomic data, including its massive size, intricate relationships, and high dimensionality.\n\nThe GenomicRanges package in Bioconductor covers a wide range of use cases related to the management and analysis of genomic data. Here are some key examples:\n\n* Genomic Feature Manipulation\n  : The GenomicRanges and GRanges classes can be used to represent and manipulate various genomic features such as genes, transcripts, exons, or single-nucleotide polymorphisms (SNPs). Users can query, subset, resize, shift, or sort these features based on their genomic coordinates.\n* Genomic Interval Operations\n  : The GenomicRanges package provides functions for performing operations on genomic intervals, such as finding overlaps, nearest neighbors, or disjoint intervals. These operations are fundamental to many types of genomic data analyses, such as identifying genes that overlap with ChIP-seq peaks, or finding variants that are in close proximity to each other.\n* Alignments and Coverage\n  : The GAlignments and GAlignmentPairs classes can be used to represent alignments of sequencing reads to a reference genome, such as those produced by a read aligner. Users can then compute coverage of these alignments over genomic ranges of interest, which is a common task in RNA-seq or ChIP-seq analysis.\n* Annotation and Metadata Handling\n  : The metadata column of a GRanges object can be used to store various types of annotation data associated with genomic ranges, such as gene names, gene biotypes, or experimental scores. This makes it easy to perform analyses that integrate genomic coordinates with other types of biological information.\n* Genome Arithmetic\n  : The GenomicRanges package supports a version of \"genome arithmetic\", which includes set operations (union, intersection, set difference) as well as other operations (like coverage, complement, or reduction) that are adapted to the specificities of genomic data.\n* Efficient Data Handling\n  : The CompressedGRangesList class provides a space-efficient way to represent a large list of GRanges objects, which is particularly useful when working with large genomic datasets, such as whole-genome sequencing data.\n\nThe GenomicRanges package in Bioconductor uses the S4 class system (see @tbl-genomic-ranges-classes), which is a part of the methods package in R. The S4 system is a more rigorous and formal approach to object-oriented programming in R, providing enhanced capabilities for object design and function dispatch.\n\n|Class Name           |Description                                                                     |Potential Use |\n|---------------------|--------------------------------------------------------------------------------|------|\n|GRanges              |Represents a collection of genomic ranges and associated variables.             |ChipSeq peaks, CpG islands, etc. |\n|GRangesList          |Represents a list of GenomicRanges objects.                                     |transcript models (exons, introns) |\n|RangesList           |Represents a list of Ranges objects.                                            |  |\n|IRanges              |Represents a collection of integer ranges.                                      |used mainly to *build* GRanges, etc. |\n|GPos                 |Represents genomic positions.                                                   |SNPs or other single nicleotide locations |\n|GAlignments          |Represents alignments against a reference genome.                               |Sequence read locations from a BAM file |\n|GAlignmentPairs      |Represents pairs of alignments, typically representing a single fragment of DNA.|Paired-end sequence alignments |\n\n: Classes within the GenomicRanges package. Each class has a slightly different use case.  {#tbl-genomic-ranges-classes}{tbl-colwidths=\"[20,40,40]\"}\n\nIn the context of the GenomicRanges package, the S4 class system allows for the creation of complex, structured data objects that can effectively encapsulate genomic intervals and associated data. This system enables the package to handle the complexity and intricacy of genomic data.\n\nFor example, the GenomicRanges class in the package is an S4 class that combines several basic data types into a composite object. It includes slots for sequence names (seqnames), ranges (start and end positions), strand information, and metadata. Each slot in the S4 class corresponds to a specific component of the genomic data, and methods (see @tbl-single-granges-methods and @tbl-multiple-granges-methods) can be defined to interact with these slots in a structured and predictable way.\n\n| **Method**            | **Description**                                                                         |\n|-----------------------|-----------------------------------------------------------------------------------------|\n| **length**            | Returns the number of ranges in the GRanges object.                                     |\n| **seqnames**          | Retrieves the sequence names of the ranges.                                             |\n| **ranges**            | Retrieves the start and end positions of the ranges.                                    |\n| **strand**            | Retrieves the strand information of the ranges.                                         |\n| **elementMetadata**   | Retrieves the metadata associated with the ranges.                                      |\n| **seqlevels**         | Returns the levels of the factor that the seqnames slot is derived from.                |\n| **seqinfo**           | Retrieves the Seqinfo (sequence information) object associated with the GRanges object. |\n| **start, end, width** | Retrieve or set the start or end positions, or the width of the ranges.                 |\n| **resize**            | Resizes the ranges.                                                                     |\n| **subset, [, [[, $**  | Subset or extract elements from the GRanges object.                                     |\n| **sort**              | Sorts the GRanges object.                                                               |\n| **shift**             | Shifts the ranges by a certain number of base pairs.                                    |\n\n: Methods for accessing, manipulating single objects {#tbl-single-granges-methods}\n\nThe S4 class system also supports inheritance, which allows for the creation of specialized subclasses that share certain characteristics with a parent class but have additional features or behaviors.\n\nThe S4 system's formalism and rigor make it well-suited to the complexities of bioinformatics and genomic data analysis. It allows for the creation of robust, reliable code that can handle complex data structures and operations, making it a key part of the GenomicRanges package and other Bioconductor packages.\n\n\n\n| **Method**            | **Description**                                                                         |\n|-----------------------|-----------------------------------------------------------------------------------------|\n| **findOverlaps**      | Finds overlaps between different sets of ranges.                                        |\n| **countOverlaps**     | Counts overlaps between different sets of ranges.                                       |\n| **subsetByOverlaps**  | Subsets the ranges based on overlaps.                                                   |\n| **distanceToNearest** | Computes the distance to the nearest range in another set of ranges.                    |\n\n: Methods for comparing and combining multiple GenomicRanges-class objects {#tbl-multiple-granges-methods}\n\n\n\n\n\n\n\nTo get going, we can construct a `GRanges` object by hand as an example.\n\nThe `GRanges` class represents a collection of genomic ranges that each have a single start\nand end location on the genome. It can be used to store the location of genomic features\nsuch as contiguous binding sites, transcripts, and exons. These objects can be created by\nusing the GRanges constructor function. The following code just creates a `GRanges` object \nfrom scratch.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngr <- GRanges(\n    seqnames = Rle(c(\"chr1\", \"chr2\", \"chr1\", \"chr3\"), c(1, 3, 2, 4)),\n    ranges = IRanges(101:110, end = 111:120, names = head(letters, 10)),\n    strand = Rle(strand(c(\"-\", \"+\", \"*\", \"+\", \"-\")), c(1, 2, 2, 3, 2)),\n    score = 1:10,\n    GC = seq(1, 0, length=10))\ngr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 10 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       <Rle> <IRanges>  <Rle> | <integer> <numeric>\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  e     chr1   105-115      * |         5  0.555556\n  f     chr1   106-116      + |         6  0.444444\n  g     chr3   107-117      + |         7  0.333333\n  h     chr3   108-118      + |         8  0.222222\n  i     chr3   109-119      - |         9  0.111111\n  j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nThis creates a `GRanges` object with 10 genomic ranges. The output of the `GRanges` `show()` method\nseparates the information into a left and right hand region that are separated by `|` symbols (see @fig-granges-structure).\nThe genomic coordinates (seqnames, ranges, and strand) are located on the left-hand side\nand the metadata columns are located on the right. For this example, the\nmetadata is comprised of score and GC information, but almost anything can be stored in\nthe metadata portion of a GRanges object.\n\n![The structure of a `GRanges` object, which behaves a bit like a vector of ranges, although the analogy is not perfect. A `GRanges` object is composed of the \"Ranges\" part the lefthand box, the \"metadata\" columns (the righthand box), and a \"seqinfo\" part that describes the names and lengths of associated sequences. Only the \"Ranges\" part is required. The figure also shows a few of the \"accessors\" and approaches to subsetting a `GRanges` object.](images/granges_structure.png){#fig-granges-structure}\n\n\nThe components of the genomic coordinates within a GRanges object can be extracted using\nthe seqnames, ranges, and strand accessor functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseqnames(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfactor-Rle of length 10 with 4 runs\n  Lengths:    1    3    2    4\n  Values : chr1 chr2 chr1 chr3\nLevels(3): chr1 chr2 chr3\n```\n\n\n:::\n\n```{.r .cell-code}\nranges(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIRanges object with 10 ranges and 0 metadata columns:\n        start       end     width\n    <integer> <integer> <integer>\n  a       101       111        11\n  b       102       112        11\n  c       103       113        11\n  d       104       114        11\n  e       105       115        11\n  f       106       116        11\n  g       107       117        11\n  h       108       118        11\n  i       109       119        11\n  j       110       120        11\n```\n\n\n:::\n\n```{.r .cell-code}\nstrand(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfactor-Rle of length 10 with 5 runs\n  Lengths: 1 2 2 3 2\n  Values : - + * + -\nLevels(3): + - *\n```\n\n\n:::\n:::\n\n\nNote that the `GRanges` object has information to the \"left\" side of the `|` that has special \naccessors. The information to the right side of the `|`, when it is present, is the metadata\nand is accessed using `mcols()`, for \"metadata columns\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mcols(gr))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"DFrame\"\nattr(,\"package\")\n[1] \"S4Vectors\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmcols(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 10 rows and 2 columns\n      score        GC\n  <integer> <numeric>\na         1  1.000000\nb         2  0.888889\nc         3  0.777778\nd         4  0.666667\ne         5  0.555556\nf         6  0.444444\ng         7  0.333333\nh         8  0.222222\ni         9  0.111111\nj        10  0.000000\n```\n\n\n:::\n:::\n\n\nSince the `class` of `mcols(gr)` is DFrame, we can use our `DataFrame` approaches to \nwork with the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcols(gr)$score\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\nWe can even assign a new column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcols(gr)$AT = 1-mcols(gr)$GC\ngr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 10 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   101-111      - |         1  1.000000  0.000000\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  e     chr1   105-115      * |         5  0.555556  0.444444\n  f     chr1   106-116      + |         6  0.444444  0.555556\n  g     chr3   107-117      + |         7  0.333333  0.666667\n  h     chr3   108-118      + |         8  0.222222  0.777778\n  i     chr3   109-119      - |         9  0.111111  0.888889\n  j     chr3   110-120      - |        10  0.000000  1.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\n\nAnother common way to create a `GRanges` object is to start with a `data.frame`, perhaps created\nby hand like below or read in using `read.csv` or `read.table`. We can convert from a \n`data.frame`, when columns are named appropriately, to a `GRanges` object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_regions = data.frame(chromosome = rep(\"chr1\",10),\n                        start=seq(1000,10000,1000),\n                        end=seq(1100, 10100, 1000))\nas(df_regions,'GRanges') # note that names have to match with GRanges slots\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 10 ranges and 0 metadata columns:\n       seqnames      ranges strand\n          <Rle>   <IRanges>  <Rle>\n   [1]     chr1   1000-1100      *\n   [2]     chr1   2000-2100      *\n   [3]     chr1   3000-3100      *\n   [4]     chr1   4000-4100      *\n   [5]     chr1   5000-5100      *\n   [6]     chr1   6000-6100      *\n   [7]     chr1   7000-7100      *\n   [8]     chr1   8000-8100      *\n   [9]     chr1   9000-9100      *\n  [10]     chr1 10000-10100      *\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n```\n\n\n:::\n\n```{.r .cell-code}\n## fix column name\ncolnames(df_regions)[1] = 'seqnames'\ngr2 = as(df_regions,'GRanges')\ngr2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 10 ranges and 0 metadata columns:\n       seqnames      ranges strand\n          <Rle>   <IRanges>  <Rle>\n   [1]     chr1   1000-1100      *\n   [2]     chr1   2000-2100      *\n   [3]     chr1   3000-3100      *\n   [4]     chr1   4000-4100      *\n   [5]     chr1   5000-5100      *\n   [6]     chr1   6000-6100      *\n   [7]     chr1   7000-7100      *\n   [8]     chr1   8000-8100      *\n   [9]     chr1   9000-9100      *\n  [10]     chr1 10000-10100      *\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\n`GRanges` have one-dimensional-like behavior. For instance, we can check the `length` and \neven give `GRanges` names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n### Subsetting GRanges objects\n\nWhile `GRanges` objects look a bit like a `data.frame`, they can be thought of\nas vectors with associated ranges. Subsetting, then, works very similarly to\nvectors. To subset a `GRanges` object to include only second and third regions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngr[2:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nThat said, if the `GRanges` object has metadata columns, we can also treat\nit like a two-dimensional object kind of like a data.frame. Note that\nthe information to the left of the `|` is not like a `data.frame`, so\nwe *cannot* do something like `gr$seqnames`. Here is an example of subsetting\nwith the subset of one metadata column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngr[2:3, \"GC\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 1 metadata column:\n    seqnames    ranges strand |        GC\n       <Rle> <IRanges>  <Rle> | <numeric>\n  b     chr2   102-112      + |  0.888889\n  c     chr2   103-113      + |  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nThe usual `head()` and `tail()` also work just fine.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(gr,n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   101-111      - |         1  1.000000  0.000000\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(gr,n=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  i     chr3   109-119      - |         9  0.111111  0.888889\n  j     chr3   110-120      - |        10  0.000000  1.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\n### Interval operations on one GRanges object\n\n#### Intra-range methods\n\nThe methods described in this section work *one-region-at-a-time* and are, therefore, called\n\"intra-region\" methods. Methods that work across all regions are described below \nin the [Inter-range methods] section.\n\nThe `GRanges` class has accessors for the \"ranges\" part of the data. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Make a smaller GRanges subset\ng <- gr[1:3]\nstart(g) # to get start locations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 101 102 103\n```\n\n\n:::\n\n```{.r .cell-code}\nend(g)   # to get end locations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 111 112 113\n```\n\n\n:::\n\n```{.r .cell-code}\nwidth(g) # to get the \"widths\" of each range\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 11 11\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(g) # to get the \"range\" for each sequence (min(start) through max(end))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr1   101-111      -\n  [2]     chr2   102-113      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nThe GRanges class also has many methods for manipulating the ranges. The methods can\nbe classified as intra-range methods, inter-range methods, and between-range methods.\nIntra-range methods operate on each element of a GRanges object independent of the other\nranges in the object. For example, the flank method can be used to recover regions flanking\nthe set of ranges represented by the GRanges object. So to get a GRanges object containing\nthe ranges that include the 10 bases *upstream* of the ranges:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflank(g, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 3 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   112-121      - |         1  1.000000  0.000000\n  b     chr2    92-101      + |         2  0.888889  0.111111\n  c     chr2    93-102      + |         3  0.777778  0.222222\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nNote how `flank` pays attention to \"strand\". \nTo get the flanking regions *downstream* of the ranges, we can do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflank(g, 10, start=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 3 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1    91-100      - |         1  1.000000  0.000000\n  b     chr2   113-122      + |         2  0.888889  0.111111\n  c     chr2   114-123      + |         3  0.777778  0.222222\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nOther examples of intra-range methods include `resize` and `shift`. The shift method will\nmove the ranges by a specific number of base pairs, and the resize method will extend the\nranges by a specified width.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshift(g, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 3 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   106-116      - |         1  1.000000  0.000000\n  b     chr2   107-117      + |         2  0.888889  0.111111\n  c     chr2   108-118      + |         3  0.777778  0.222222\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n\n```{.r .cell-code}\nresize(g, 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 3 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1    82-111      - |         1  1.000000  0.000000\n  b     chr2   102-131      + |         2  0.888889  0.111111\n  c     chr2   103-132      + |         3  0.777778  0.222222\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nThe [`GenomicRanges`](http://bioconductor.org/packages/GenomicRanges.html) help page `?\"intra-range-methods\"` summarizes these methods.\n\n#### Inter-range methods\n\nInter-range methods involve comparisons between ranges in a single GRanges object. For\ninstance, the reduce method will align the ranges and merge overlapping ranges to produce\na simplified set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreduce(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr1   101-111      -\n  [2]     chr2   102-113      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nThe reduce method could, for example, be used to collapse individual overlapping coding\nexons into a single set of coding regions.\n\nSometimes one is interested in the gaps or the qualities of the gaps between the ranges\nrepresented by your GRanges object. The gaps method provides this information:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngaps(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr1     1-100      -\n  [2]     chr2     1-101      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nIn this case, we have not specified the lengths of the chromosomes, so Bioconductor is \nmaking the assumption (incorrectly) that the chromosomes end at the largest location\non each chromosome. We can correct this by setting the `seqlengths` correctly, but\nwe can ignore that detail for now.\n\nThe disjoin method represents a GRanges object as a collection of non-overlapping ranges:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndisjoin(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 4 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr1   101-111      -\n  [2]     chr2       102      +\n  [3]     chr2   103-112      +\n  [4]     chr2       113      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\n\nThe `coverage` method quantifies the degree of overlap for all the ranges in a GRanges object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoverage(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRleList of length 3\n$chr1\ninteger-Rle of length 111 with 2 runs\n  Lengths: 100  11\n  Values :   0   1\n\n$chr2\ninteger-Rle of length 113 with 4 runs\n  Lengths: 101   1  10   1\n  Values :   0   1   2   1\n\n$chr3\ninteger-Rle of length 0 with 0 runs\n  Lengths: \n  Values : \n```\n\n\n:::\n:::\n\n\nThe coverage is summarized as a `list` of coverages, one for each chromosome. \nThe `Rle` class is used to store the values. Sometimes, one must convert these \nvalues to `numeric` using `as.numeric`. In many cases, this will happen automatically,\nthough. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncovg = coverage(g)\ncovg_chr2 = covg[['chr2']]\nplot(covg_chr2, type='l')\n```\n\n::: {.cell-output-display}\n![](ranges_and_signals_files/figure-epub/coveragegr2-1.png)\n:::\n:::\n\n\nSee the [`GenomicRanges`](http://bioconductor.org/packages/GenomicRanges.html) help page `?\"intra-range-methods\"` for more details.\n\n### Set operations for GRanges objects\n\nBetween-range methods calculate relationships between different GRanges objects. Of central\nimportance are findOverlaps and related operations; these are discussed below. Additional\noperations treat GRanges as mathematical sets of coordinates; union(g, g2) is the union of\nthe coordinates in g and g2. Here are examples for calculating the union, the intersect and\nthe asymmetric difference (using setdiff).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng2 <- head(gr, n=2)\nGenomicRanges::union(g, g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr1   101-111      -\n  [2]     chr2   102-113      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n\n```{.r .cell-code}\nGenomicRanges::intersect(g, g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr1   101-111      -\n  [2]     chr2   102-112      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n\n```{.r .cell-code}\nGenomicRanges::setdiff(g, g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 1 range and 0 metadata columns:\n      seqnames    ranges strand\n         <Rle> <IRanges>  <Rle>\n  [1]     chr2       113      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nThere is extensive additional help available or by looking at the vignettes\nin at the [`GenomicRanges`](http://bioconductor.org/packages/GenomicRanges.html) pages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?GRanges\n```\n:::\n\n\nThere are also many possible `methods` that work with `GRanges` objects. To\nsee a complete list (long), try:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class=\"GRanges\")\n```\n:::\n\n\n\n## GRangesList\n\nSome important genomic features, such as spliced transcripts that are are comprised of exons,\nare inherently compound structures. Such a feature makes much more sense when expressed\nas a compound object such as a GRangesList. If we thing of each transcript as a set of exons,\neach transcript would be summarized as a `GRanges` object. However, if we have multiple transcripts,\nwe want to somehow keep them separate, with each transcript having its own exons. The `GRangesList`\nis then a list of `GRanges` objects that. Continuing with the transcripts thought, a `GRangesList`\ncan contain all the transcripts and their exons; each transcript is an element in the list. \n\n![The structure of a GRangesList, which is a `list` of GRanges objects. While the analogy is not perfect, a `GRangesList` behaves a bit like a list. Each element in the `GRangesList` *is* a `Granges` object. A common use case for a `GRangesList` is to store a list of transcripts, each of which have exons as the regions in the `GRanges`. ](images/granges_list_structure.png){#fig-granges-list-structure}\n\n\nWhenever genomic features consist of multiple\nranges that are grouped by a parent feature, they can be represented as a GRangesList\nobject. Consider the simple example of the two transcript GRangesList below created using\nthe GRangesList constructor.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngr1 <- GRanges(\n    seqnames = \"chr1\", \n    ranges = IRanges(103, 106),\n    strand = \"+\", \n    score = 5L, GC = 0.45)\ngr2 <- GRanges(\n    seqnames = c(\"chr1\", \"chr1\"),\n    ranges = IRanges(c(107, 113), width = 3),\n    strand = c(\"+\", \"-\"), \n    score = 3:4, GC = c(0.3, 0.5))\n```\n:::\n\n\nThe `gr1` and `gr2` are each `GRanges` objects. We can combine them into a \"named\"\n`GRangesList` like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrl <- GRangesList(\"txA\" = gr1, \"txB\" = gr2)\ngrl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRangesList object of length 2:\n$txA\nGRanges object with 1 range and 2 metadata columns:\n      seqnames    ranges strand |     score        GC\n         <Rle> <IRanges>  <Rle> | <integer> <numeric>\n  [1]     chr1   103-106      + |         5      0.45\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n\n$txB\nGRanges object with 2 ranges and 2 metadata columns:\n      seqnames    ranges strand |     score        GC\n         <Rle> <IRanges>  <Rle> | <integer> <numeric>\n  [1]     chr1   107-109      + |         3       0.3\n  [2]     chr1   113-115      - |         4       0.5\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nThe `show` method for a `GRangesList` object displays it as a named list of `GRanges` objects,\nwhere the names of this list are considered to be the names of the grouping feature. In the\nexample above, the groups of individual exon ranges are represented as separate `GRanges`\nobjects which are further organized into a list structure where each element name is a transcript\nname. Many other combinations of grouped and labeled `GRanges` objects are possible\nof course, but this example is a common arrangement.\n\nIn some cases, `GRangesList`s behave quite similarly to `GRanges` objects.\n\n### Basic _GRangesList_ accessors\n\nJust as with GRanges object, the components of the genomic coordinates within a GRangesList\nobject can be extracted using simple accessor methods. Not surprisingly, the GRangesList\nobjects have many of the same accessors as GRanges objects. The difference is that many\nof these methods return a list since the input is now essentially a list of GRanges objects.\nHere are a few examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseqnames(grl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRleList of length 2\n$txA\nfactor-Rle of length 1 with 1 run\n  Lengths:    1\n  Values : chr1\nLevels(1): chr1\n\n$txB\nfactor-Rle of length 2 with 1 run\n  Lengths:    2\n  Values : chr1\nLevels(1): chr1\n```\n\n\n:::\n\n```{.r .cell-code}\nranges(grl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIRangesList object of length 2:\n$txA\nIRanges object with 1 range and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]       103       106         4\n\n$txB\nIRanges object with 2 ranges and 0 metadata columns:\n          start       end     width\n      <integer> <integer> <integer>\n  [1]       107       109         3\n  [2]       113       115         3\n```\n\n\n:::\n\n```{.r .cell-code}\nstrand(grl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRleList of length 2\n$txA\nfactor-Rle of length 1 with 1 run\n  Lengths: 1\n  Values : +\nLevels(3): + - *\n\n$txB\nfactor-Rle of length 2 with 2 runs\n  Lengths: 1 1\n  Values : + -\nLevels(3): + - *\n```\n\n\n:::\n:::\n\n\nThe length and names methods will return the length or names of the list and the seqlengths\nmethod will return the set of sequence lengths.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(grl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(grl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"txA\" \"txB\"\n```\n\n\n:::\n\n```{.r .cell-code}\nseqlengths(grl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nchr1 \n  NA \n```\n\n\n:::\n:::\n\n\n\n## Relationships between region sets\n\nOne of the more powerful approaches to genomic data integration is to ask\nabout the relationship between sets of genomic ranges. The key features of \nthis process are to look at overlaps and distances to the nearest feature.\nThese functionalities, combined with the operations like `flank` and `resize`, \nfor instance, allow pretty useful analyses with relatively little code.\nIn general, these operations are *very* fast, even on thousands to millions\nof regions. \n\n### Overlaps\n\nThe findOverlaps method in the GenomicRanges package is a very useful function that allows users to identify overlaps between two sets of genomic ranges.\n\nHere's how it works:\n\n* Inputs\n  : The function requires two GRanges objects, referred to as query and subject.\n* Processing\n  : The function then compares every range in the query object with every range in the subject object, looking for overlaps. An overlap is defined as any instance where the range in the query object intersects with a range in the subject object.\n* Output\n  : The function returns a Hits (see `?Hits`) object, which is a compact representation of the matrix of overlaps. Each entry in the Hits object corresponds to a pair of overlapping ranges, with the query index and the subject index.\n\nHere is an example of how you might use the findOverlaps function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create two GRanges objects\ngr1 <- gr[1:4]\ngr2 <- gr[3:8]\ngr1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 4 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   101-111      - |         1  1.000000  0.000000\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n\n```{.r .cell-code}\ngr2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 6 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  e     chr1   105-115      * |         5  0.555556  0.444444\n  f     chr1   106-116      + |         6  0.444444  0.555556\n  g     chr3   107-117      + |         7  0.333333  0.666667\n  h     chr3   108-118      + |         8  0.222222  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Find overlaps  \noverlaps <- findOverlaps(query = gr1, subject = gr2)  \noverlaps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHits object with 7 hits and 0 metadata columns:\n      queryHits subjectHits\n      <integer>   <integer>\n  [1]         1           3\n  [2]         2           1\n  [3]         2           2\n  [4]         3           1\n  [5]         3           2\n  [6]         4           1\n  [7]         4           2\n  -------\n  queryLength: 4 / subjectLength: 6\n```\n\n\n:::\n:::\n\n\nIn the resulting overlaps object, each row corresponds to an overlapping pair of ranges, with the first column giving the index of the range in gr1 and the second column giving the index of the overlapping range in gr2.\n\nIf you are interested in only the `queryHits` or the `subjectHits`, there are \naccessors for those (ie., `queryHits(overlaps)`). To get the actual ranges\nthat overlap, you can use the `subjectHits` or `queryHits` as an index into\nthe original `GRanges` object. \n\nSpend some time looking at these results. Note how the strand comes into play\nwhen determining overlaps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngr1[queryHits(overlaps)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 7 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   101-111      - |         1  1.000000  0.000000\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n\n```{.r .cell-code}\ngr2[subjectHits(overlaps)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 7 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  e     chr1   105-115      * |         5  0.555556  0.444444\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nAs you might expect, the `countOverlaps` method counts the regions in the\nsecond `GRanges` that overlap with those that overlap\nwith each element of the first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountOverlaps(gr1, gr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c d \n1 2 2 2 \n```\n\n\n:::\n:::\n\n\nThe `subsetByOverlaps` method simply subsets the query `GRanges` object to include\n*only* those that overlap the subject. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubsetByOverlaps(gr1, gr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 4 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   101-111      - |         1  1.000000  0.000000\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\nIn some cases, you may be interested in only one hit when doing \noverlaps. Note the `select` parameter. See the help for `findOverlaps`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfindOverlaps(gr1, gr2, select=\"first\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 1 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nfindOverlaps(gr1, gr2, select=\"first\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 1 1 1\n```\n\n\n:::\n:::\n\n\nThe `%over%` logical operator allows us to do similar things to \n`findOverlaps` and `subsetByOverlaps`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngr2 %over% gr1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ngr1[gr1 %over% gr2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 4 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   101-111      - |         1  1.000000  0.000000\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\n\n### Nearest feature\n\nThere are a number of useful methods that find the nearest feature (region) in a second set\nfor each element in the first set. \n\nWe can review our two `GRanges` toy objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 3 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   101-111      - |         1  1.000000  0.000000\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n\n```{.r .cell-code}\ngr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGRanges object with 10 ranges and 3 metadata columns:\n    seqnames    ranges strand |     score        GC        AT\n       <Rle> <IRanges>  <Rle> | <integer> <numeric> <numeric>\n  a     chr1   101-111      - |         1  1.000000  0.000000\n  b     chr2   102-112      + |         2  0.888889  0.111111\n  c     chr2   103-113      + |         3  0.777778  0.222222\n  d     chr2   104-114      * |         4  0.666667  0.333333\n  e     chr1   105-115      * |         5  0.555556  0.444444\n  f     chr1   106-116      + |         6  0.444444  0.555556\n  g     chr3   107-117      + |         7  0.333333  0.666667\n  h     chr3   108-118      + |         8  0.222222  0.777778\n  i     chr3   109-119      - |         9  0.111111  0.888889\n  j     chr3   110-120      - |        10  0.000000  1.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n```\n\n\n:::\n:::\n\n\n- nearest: Performs conventional nearest neighbor finding. Returns an integer vector containing the index of the nearest neighbor range in subject for each range in x. If there is no nearest neighbor NA is returned. For details of the algorithm see the man page in the IRanges package (?nearest).\n\n- precede: For each range in x, precede returns the index of the range in subject that is directly preceded by the range in x. Overlapping ranges are excluded. NA is returned when there are no qualifying ranges in subject.\n\n- follow: The opposite of precede, follow returns the index of the range in subject that is directly followed by the range in x. Overlapping ranges are excluded. NA is returned when there are no qualifying ranges in subject.\n\nOrientation and strand for precede and follow: Orientation is 5' to 3', consistent with the direction of translation. Because positional numbering along a chromosome is from left to right and transcription takes place from 5' to 3', precede and follow can appear to have ‘opposite’ behavior on the + and - strand. Using positions 5 and 6 as an example, 5 precedes 6 on the + strand but follows 6 on the - strand.\n\nThe table below outlines the orientation when ranges on different strands are compared. In general, a feature on * is considered to belong to both strands. The single exception is when both x and subject are * in which case both are treated as +.\n\n\n```\n       x  |  subject  |  orientation \n     -----+-----------+----------------\na)     +  |  +        |  ---> \nb)     +  |  -        |  NA\nc)     +  |  *        |  --->\nd)     -  |  +        |  NA\ne)     -  |  -        |  <---\nf)     -  |  *        |  <---\ng)     *  |  +        |  --->\nh)     *  |  -        |  <---\ni)     *  |  *        |  --->  (the only situation where * arbitrarily means +)\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres = nearest(g, gr)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 4 4\n```\n\n\n:::\n:::\n\n\nWhile `nearest` and friends give the index of the nearest feature, the distance\nto the nearest is sometimes also useful to have. The `distanceToNearest`\nmethod calculates the nearest feature as well as reporting the distance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres = distanceToNearest(g, gr)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHits object with 3 hits and 1 metadata column:\n      queryHits subjectHits |  distance\n      <integer>   <integer> | <integer>\n  [1]         1           5 |         0\n  [2]         2           4 |         0\n  [3]         3           4 |         0\n  -------\n  queryLength: 3 / subjectLength: 10\n```\n\n\n:::\n:::\n\n\n\n## Gene models\n\nThe `TxDb` package provides a convenient interface to gene models from\na variety of sources. The `TxDb.Hsapiens.UCSC.hg38.knownGene` package\nprovides access to the UCSC knownGene gene model for the hg19 build of\nthe human genome. \n\n![A graphical representation of range operations demonstrated on a gene model.](images/range_operations_diagram.png){#fig-range-operations}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(TxDb.Hsapiens.UCSC.hg38.knownGene)\ntxdb <- TxDb.Hsapiens.UCSC.hg38.knownGene\n```\n:::\n\n\nThe `transcripts` function returns a `GRanges` object with the\ntranscripts for all genes in the database. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntx <- transcripts(txdb)\n```\n:::\n\n\nThe `exons` function returns a `GRanges` object with the exons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex <- exons(txdb)\n```\n:::\n\n\nThe `genes` function returns a `GRanges` object with the genes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngn <- genes(txdb)\n```\n:::\n\n\n",
    "supporting": [
      "ranges_and_signals_files/figure-epub"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}