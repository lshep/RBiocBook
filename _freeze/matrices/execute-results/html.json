{
  "hash": "c1bd70c8ca20598f927250b0102dd0ae",
  "result": {
    "engine": "knitr",
    "markdown": "# Matrices\n\nA _matrix_ is a rectangular collection of the same data type (see @fig-datastructures_schematic). It can be viewed\nas a collection of column vectors all of the same length and the same type\n(i.e. numeric, character or logical) OR a collection of row vectors, again all\nof the same type and length. A _data.frame_ is *also* a rectangular array. All\nof the columns must be the same length, but they **may be** of *different* types.\nThe rows and columns of a matrix or data frame can be given names. However\nthese are implemented differently in R; many operations will work for one but\nnot both, often a source of confusion.\n\n![A matrix is a collection of column vectors.](images/datastructures_schematic.png){#fig-datastructures_schematic}\n\n\n## Creating a matrix\n\nThere are many ways to create a matrix in R. One of the simplest is to use the\n`matrix()` function. In the code below, we'll create a matrix from a vector\nfrom 1:16.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n```\n\n\n:::\n:::\n\n\nThe same is possible, but specifying that the matrix be \"filled\" by row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:16,nrow=4,byrow = TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n```\n\n\n:::\n:::\n\n\nNotice the subtle difference in the order that the numbers go into the matrix.\n\n\nWe can also build a matrix from parts by \"binding\" vectors together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10 \ny <- rnorm(10)\n```\n:::\n\n\nEach of the vectors above is of length 10 and both are \"numeric\", so we can make\nthem into a matrix. Using `rbind` binds rows (**r**) into a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- rbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1]        [,2]     [,3]       [,4]       [,5]      [,6]      [,7]\nx  1.000000  2.00000000 3.000000  4.0000000  5.0000000  6.000000  7.000000\ny -1.151193 -0.09401175 1.016198 -0.1788507 -0.9842443 -1.214426 -1.089794\n      [,8]       [,9]      [,10]\nx  8.00000  9.0000000 10.0000000\ny -2.23542 -0.4612952  0.4178649\n```\n\n\n:::\n:::\n\n\nThe alternative to `rbind` is `cbind` that binds columns (**c**) together. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- cbind(x,y)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x           y\n [1,]  1 -1.15119280\n [2,]  2 -0.09401175\n [3,]  3  1.01619820\n [4,]  4 -0.17885066\n [5,]  5 -0.98424426\n [6,]  6 -1.21442596\n [7,]  7 -1.08979410\n [8,]  8 -2.23542017\n [9,]  9 -0.46129523\n[10,] 10  0.41786492\n```\n\n\n:::\n:::\n\n\nInspecting the names associated with rows and columns is often useful,\nparticularly if the names have human meaning. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\nWe can also change the names of the matrix by assigning _valid_ names to the \ncolumns or rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mat) = c('apples','oranges')\ncolnames(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apples\"  \"oranges\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      apples     oranges\n [1,]      1 -1.15119280\n [2,]      2 -0.09401175\n [3,]      3  1.01619820\n [4,]      4 -0.17885066\n [5,]      5 -0.98424426\n [6,]      6 -1.21442596\n [7,]      7 -1.08979410\n [8,]      8 -2.23542017\n [9,]      9 -0.46129523\n[10,]     10  0.41786492\n```\n\n\n:::\n:::\n\n\n\n\nMatrices have dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  2\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n## Accessing elements of a matrix\n\nIndexing for matrices works as for vectors except that we now need to\ninclude both the row and column (in that order). We can access elements \nof a matrix using the square bracket [ indexing method. Elements can be \naccessed as `var[r, c]`. Here, `r` and `c` are vectors describing the elements\nof the matrix to select.\n\n::: {.callout-important}\nThe indices in R start with one, meaning that the first element of a vector or the first row/column of a matrix is indexed as one.\n\nThis is different from some other programming languages, such as Python, which use zero-based indexing, meaning that the first element of a vector or the first row/column of a matrix is indexed as zero.\n\nIt is important to be aware of this difference when working with data in R, especially if you are coming from a programming background that uses zero-based indexing. Using the wrong index can lead to unexpected results or errors in your code.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The 2nd element of the 1st row of mat\nmat[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  oranges \n-1.151193 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first ROW of mat\nmat[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   apples   oranges \n 1.000000 -1.151193 \n```\n\n\n:::\n\n```{.r .cell-code}\n# The first COLUMN of mat\nmat[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# and all elements of mat that are > 4; note no comma\nmat[mat>4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n## [1]  5  6  7  8  9 10\n```\n:::\n\n\n::: {.callout-caution}\nNote that in the last case, there is no \",\", so R treats the matrix as a long \nvector (length=20). This is convenient, sometimes, but it can also be a source \nof error, as some code may \"work\" but be doing something unexpected.\n\n:::\n\n\n\nWe can also use indexing to exclude a row or column by prefixing the selection\nwith a `-` sign.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[,-1]       # remove first column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -1.15119280 -0.09401175  1.01619820 -0.17885066 -0.98424426 -1.21442596\n [7] -1.08979410 -2.23542017 -0.46129523  0.41786492\n```\n\n\n:::\n\n```{.r .cell-code}\nmat[-c(1:5),]  # remove first five rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     apples    oranges\n[1,]      6 -1.2144260\n[2,]      7 -1.0897941\n[3,]      8 -2.2354202\n[4,]      9 -0.4612952\n[5,]     10  0.4178649\n```\n\n\n:::\n:::\n\n\n## Changing values in a matrix\n\nWe can create a matrix filled with random values drawn from a normal\ndistribution for our work below. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = matrix(rnorm(20),nrow=10)\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                V2         \n Min.   :-1.8330   Min.   :-2.0497  \n 1st Qu.:-0.7606   1st Qu.:-0.4389  \n Median : 0.7864   Median : 0.6033  \n Mean   : 0.2856   Mean   : 0.6738  \n 3rd Qu.: 0.9019   3rd Qu.: 1.7985  \n Max.   : 2.3502   Max.   : 2.9927  \n```\n\n\n:::\n:::\n\n\nMultiplication and division works similarly to vectors. When multiplying by a \nvector, for example, the values of the vector are reused. In the simplest case, \nlet's multiply the matrix by a constant (vector of length 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# multiply all values in the matrix by 20\nm2 = m*20\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1                V2         \n Min.   :-36.661   Min.   :-40.994  \n 1st Qu.:-15.211   1st Qu.: -8.779  \n Median : 15.729   Median : 12.065  \n Mean   :  5.711   Mean   : 13.475  \n 3rd Qu.: 18.038   3rd Qu.: 35.969  \n Max.   : 47.004   Max.   : 59.854  \n```\n\n\n:::\n:::\n\n\nBy combining subsetting with assignment, we can make changes to just part of a \nmatrix. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# and add 100 to the first column of m\nm2[,1] = m2[,1] + 100\n# summarize m\nsummary(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1               V2         \n Min.   : 63.34   Min.   :-40.994  \n 1st Qu.: 84.79   1st Qu.: -8.779  \n Median :115.73   Median : 12.065  \n Mean   :105.71   Mean   : 13.475  \n 3rd Qu.:118.04   3rd Qu.: 35.969  \n Max.   :147.00   Max.   : 59.854  \n```\n\n\n:::\n:::\n\n\nA somewhat common transformation for a matrix is to transpose which changes\nrows to columns. One might need to do this if an assay output from a lab \nmachine puts samples in rows and genes in columns, for example, while in \nBioconductor/R, we often want the samples in columns and the genes in rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]       [,2]      [,3]      [,4]      [,5]      [,6]       [,7]\n[1,] 116.89722 147.004355 116.19088  99.50672 121.81061  63.33906 118.417923\n[2,]  59.85408  -9.877637  12.99534 -40.99377  51.33027 -11.52863  -5.482144\n         [,8]      [,9]    [,10]\n[1,] 78.79549 115.26654 79.88263\n[2,] 11.13558  29.04172 38.27873\n```\n\n\n:::\n:::\n\n\n## Calculations on matrix rows and columns\n\nAgain, we just need a matrix to play with. We'll use `rnorm` again, but with a\nslight twist. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3 = matrix(rnorm(100,5,2),ncol=10) # what does the 5 mean here? And the 2?\n```\n:::\n\n\nSince these data are from a normal distribution, we can look at a row (or column)\nto see what the mean and standard deviation are.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.709692\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[,1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.425251\n```\n\n\n:::\n\n```{.r .cell-code}\n# or a row\nmean(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.86667\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(m3[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.102434\n```\n\n\n:::\n:::\n\n\nThere are some useful convenience functions for computing means and sums \nof data in **all** of the columns and rows of matrices. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6.709692 4.968957 5.961377 4.572742 5.293570 4.130627 4.195079 4.475901\n [9] 5.076318 5.360578\n```\n\n\n:::\n\n```{.r .cell-code}\nrowMeans(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 4.866670 4.100055 4.814678 5.800869 5.813489 5.485770 4.889247 5.444376\n [9] 4.603745 4.925941\n```\n\n\n:::\n\n```{.r .cell-code}\nrowSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 48.66670 41.00055 48.14678 58.00869 58.13489 54.85770 48.89247 54.44376\n [9] 46.03745 49.25941\n```\n\n\n:::\n\n```{.r .cell-code}\ncolSums(m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 67.09692 49.68957 59.61377 45.72742 52.93570 41.30627 41.95079 44.75901\n [9] 50.76318 53.60578\n```\n\n\n:::\n:::\n\n\nWe can look at the distribution of column means:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save as a variable\ncmeans = colMeans(m3)\nsummary(cmeans)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.131   4.500   5.023   5.074   5.344   6.710 \n```\n\n\n:::\n:::\n\nNote that this is centered pretty closely around the selected mean of `5` above.\n\nHow about the standard deviation? There is not a `colSd` function, but it turns\nout that we can easily apply functions that take vectors as input, like `sd` and\n\"apply\" them across either the rows (the first dimension) or columns (the second)\ndimension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsds = apply(m3, 2, sd)\nsummary(csds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7965  1.8319  2.0329  1.8965  2.1867  2.3309 \n```\n\n\n:::\n:::\n\n\nAgain, take a look at the distribution which is centered quite close to the \nselected standard deviation when we created our matrix.\n\n\n## Exercises\n\n\n\n\n### Data preparation\n\nFor this set of exercises, we are going to rely on a dataset that comes with R.\nIt gives the number of sunspots per month from 1749-1983. The dataset comes as \na `ts` or time series data type which I convert to a matrix using the following\ncode. \n\nJust run the code as is and focus on the rest of the exercises. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(sunspots)\nsunspot_mat <- matrix(as.vector(sunspots),ncol=12,byrow = TRUE)\ncolnames(sunspot_mat) <- as.character(1:12)\nrownames(sunspot_mat) <- as.character(1749:1983)\n```\n:::\n\n\n### Questions\n\n-   After the conversion above, what does `sunspot_mat` look like? Use functions\nto find the number of rows, the number of columns, the class, and some basic\nsummary statistics.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ncol(sunspot_mat)\n    nrow(sunspot_mat)\n    dim(sunspot_mat)\n    summary(sunspot_mat)\n    head(sunspot_mat)\n    tail(sunspot_mat)\n    ```\n    :::\n\n\n\n-   Practice subsetting the matrix a bit by selecting:\n    - The first 10 years (rows)\n    - The month of July (7th column)\n    - The value for July, 1979 using the rowname to do the selection.\n  \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    sunspot_mat[1:10,]\n    sunspot_mat[,7]\n    sunspot_mat['1979',7]\n    ```\n    :::\n\n\n\n1.  These next few exercises take advantage of the fact that calling a univariate\nstatistical function (one that expects a vector) works for matrices by just making\na vector of all the values in the matrix. \nWhat is the highest (max) number of sunspots recorded in these data?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    max(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the minimum?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    min(sunspot_mat)\n    ```\n    :::\n\n\n1.  And the overall mean and median?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    mean(sunspot_mat)\n    median(sunspot_mat)\n    ```\n    :::\n\n\n1.  Use the `hist()` function to look at the distribution of all the monthly \nsunspot data. \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat)\n    ```\n    :::\n\n1.  Read about the `breaks` argument to `hist()` to try to increase the number of\nbreaks in the histogram to increase the resolution slightly. Adjust your `hist()`\nand breaks to your liking.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    hist(sunspot_mat, breaks=40)\n    ```\n    :::\n\n\n\n1.  Now, let's move on to summarizing the data a bit to learn about the pattern of \nsunspots varies by month or by year. Examine the dataset again. What do the\ncolumns represent? And the rows?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # just a quick glimpse of the data will give us a sense\n    head(sunspot_mat)\n    ```\n    :::\n\n\n1.  We'd like to look at the distribution of sunspots by month. How can we do that?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    # the mean of the columns is the mean number of sunspots per month.\n    colMeans(sunspot_mat)\n    \n    # Another way to write the same thing:\n    apply(sunspot_mat, 2, mean)\n    ```\n    :::\n\n1.  Assign the month summary above to a variable and summarize it to get a sense\nof the spread over months.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    monthmeans = colMeans(sunspot_mat)\n    summary(monthmeans)\n    ```\n    :::\n\n\n1.  Play the same game for years to get the per-year mean?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    ymeans = rowMeans(sunspot_mat)\n    summary(ymeans)\n    ```\n    :::\n\n\n1.  Make a plot of the yearly means. Do you see a pattern?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\n    plot(ymeans)\n    # or make it clearer\n    plot(ymeans, type='l')\n    ```\n    :::\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}